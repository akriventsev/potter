package codegen

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// SDKGenerator генератор SDK
type SDKGenerator struct {
	*BaseGenerator
}

// NewSDKGenerator создает новый генератор SDK
func NewSDKGenerator(outputDir string) *SDKGenerator {
	return &SDKGenerator{
		BaseGenerator: NewBaseGenerator("pkg/sdk", outputDir),
	}
}

// Generate генерирует SDK
func (g *SDKGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateSDKClient(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK client: %w", err)
	}

	if err := g.generateSDKConfig(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK config: %w", err)
	}

	if err := g.generateSDKTypes(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK types: %w", err)
	}

	if err := g.generateSDKExamples(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK examples: %w", err)
	}

	if err := g.generateSDKGoMod(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK go.mod: %w", err)
	}

	// Выполняем go get для получения potter framework из main ветки
	if err := g.runGoGetPotter(config); err != nil {
		return fmt.Errorf("failed to run go get potter@main: %w", err)
	}

	if err := g.generateSDKREADME(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK README: %w", err)
	}

	return nil
}

// generateSDKClient генерирует SDK client
func (g *SDKGenerator) generateSDKClient(spec *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	basePotterPath := strings.Split(potterPath, "@")[0]

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package sdk\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"time\"\n")
	content.WriteString("\n")
	content.WriteString(fmt.Sprintf("\t\"%s/framework/adapters/messagebus\"\n", basePotterPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/invoke\"\n", basePotterPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", basePotterPath))
	content.WriteString(")\n\n")

	content.WriteString("// Client SDK client для интеграции\n")
	content.WriteString("type Client struct {\n")
	content.WriteString("\tcommandInvokers map[string]interface{}\n")
	content.WriteString("\tqueryInvokers   map[string]interface{}\n")
	content.WriteString("\tconfig          *ClientConfig\n")
	content.WriteString("\tcommandBus      *invoke.AsyncCommandBus\n")
	content.WriteString("\tqueryBus        transport.QueryBus\n")
	content.WriteString("\teventAwaiter    *invoke.EventAwaiter\n")
	content.WriteString("\tcleanup         []func() error\n")
	content.WriteString("}\n\n")

	content.WriteString("// NewClient создает новый SDK client\n")
	content.WriteString("func NewClient(config *ClientConfig) (*Client, error) {\n")
	content.WriteString("\tctx := context.Background()\n")
	content.WriteString("\tclient := &Client{\n")
	content.WriteString("\t\tcommandInvokers: make(map[string]interface{}),\n")
	content.WriteString("\t\tqueryInvokers:   make(map[string]interface{}),\n")
	content.WriteString("\t\tconfig:          config,\n")
	content.WriteString("\t\tcleanup:         make([]func() error, 0),\n")
	content.WriteString("\t}\n\n")

	// Настройка транспортов
	content.WriteString("\t// Настройка транспортов\n")
	content.WriteString("\tvar commandPublisher transport.Publisher\n")
	content.WriteString("\tvar queryRequestReply transport.RequestReply\n")
	content.WriteString("\tvar eventSubscriber transport.Subscriber\n\n")

	// NATS транспорт для команд
	content.WriteString("\tif config.CommandTransport == \"NATS\" {\n")
	content.WriteString("\t\tnatsAdapter, err := messagebus.NewNATSAdapter(config.NATSUrl)\n")
	content.WriteString("\t\tif err != nil {\n")
	content.WriteString("\t\t\treturn nil, fmt.Errorf(\"failed to create NATS adapter: %w\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif err := natsAdapter.Start(ctx); err != nil {\n")
	content.WriteString("\t\t\treturn nil, fmt.Errorf(\"failed to start NATS adapter: %w\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tclient.cleanup = append(client.cleanup, func() error { return natsAdapter.Stop(ctx) })\n")
	content.WriteString("\t\tcommandPublisher = natsAdapter\n")
	content.WriteString("\t\tqueryRequestReply = natsAdapter\n")
	content.WriteString("\t\teventSubscriber = natsAdapter\n")
	content.WriteString("\t}\n\n")

	// Создание AsyncCommandBus
	content.WriteString("\t// Создание AsyncCommandBus\n")
	content.WriteString("\tif commandPublisher != nil {\n")
	content.WriteString("\t\tclient.commandBus = invoke.NewAsyncCommandBus(commandPublisher)\n")
	content.WriteString("\t}\n\n")

	// Создание QueryBus через NATS Request-Reply
	content.WriteString("\t// Создание QueryBus через NATS Request-Reply\n")
	content.WriteString("\tif queryRequestReply != nil {\n")
	content.WriteString("\t\t// Используем обертку для Request-Reply как QueryBus\n")
	content.WriteString("\t\tclient.queryBus = &natsRequestReplyQueryBus{\n")
	content.WriteString("\t\t\tadapter:    queryRequestReply,\n")
	content.WriteString("\t\t\tserializer: invoke.NewJSONSerializer(),\n")
	content.WriteString("\t\t\ttimeout:    config.Timeout,\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}\n\n")

	// Создание EventAwaiter
	content.WriteString("\t// Создание EventAwaiter\n")
	content.WriteString("\tif eventSubscriber != nil {\n")
	content.WriteString("\t\tresolver := invoke.NewDefaultSubjectResolver(\"commands\", \"events\")\n")
	content.WriteString("\t\tclient.eventAwaiter = invoke.NewEventAwaiterFromTransport(\n")
	content.WriteString("\t\t\teventSubscriber,\n")
	content.WriteString("\t\t\tinvoke.NewJSONSerializer(),\n")
	content.WriteString("\t\t\tresolver,\n")
	content.WriteString("\t\t)\n")
	content.WriteString("\t}\n\n")

	// Заполнение commandInvokers
	// Используем DTO типы для invoker, так как SDK независим от application слоя
	content.WriteString("\t// Заполнение commandInvokers\n")
	for _, cmd := range spec.Commands {
		cmdDTOType := fmt.Sprintf("%sCommandDTO", cmd.Name)
		successEvent := g.findSuccessEvent(cmd, spec)
		errorEvent := g.findErrorEvent(cmd, spec)
		successEventDTO := successEvent + "DTO"
		errorEventDTO := errorEvent + "DTO"

		content.WriteString(fmt.Sprintf("\t// %s command invoker\n", cmd.Name))
		content.WriteString("\tif client.commandBus != nil && client.eventAwaiter != nil {\n")
		content.WriteString(fmt.Sprintf("\t\tinvoker := invoke.NewCommandInvoker[%s, %s, %s](\n",
			cmdDTOType, successEventDTO, errorEventDTO))
		content.WriteString("\t\t\tclient.commandBus,\n")
		content.WriteString("\t\t\tclient.eventAwaiter,\n")
		content.WriteString(fmt.Sprintf("\t\t\t%q,\n", g.getEventType(successEvent, cmd, spec)))
		content.WriteString(fmt.Sprintf("\t\t\t%q,\n", g.getEventType(errorEvent, cmd, spec)))
		content.WriteString("\t\t)\n")
		content.WriteString("\t\tif config.Timeout > 0 {\n")
		content.WriteString("\t\t\tinvoker = invoker.WithTimeout(config.Timeout)\n")
		content.WriteString("\t\t}\n")
		content.WriteString(fmt.Sprintf("\t\tclient.commandInvokers[%q] = invoker\n", g.converter.ToSnakeCase(cmd.Name)))
		content.WriteString("\t}\n\n")
	}

	// Заполнение queryInvokers
	// Используем DTO типы для invoker, так как SDK независим от application слоя
	content.WriteString("\t// Заполнение queryInvokers\n")
	for _, query := range spec.Queries {
		queryDTOType := fmt.Sprintf("%sQueryDTO", query.Name)
		responseDTOType := fmt.Sprintf("%sResponseDTO", query.Name)

		content.WriteString(fmt.Sprintf("\t// %s query invoker\n", query.Name))
		content.WriteString("\tif client.queryBus != nil {\n")
		content.WriteString(fmt.Sprintf("\t\tinvoker := invoke.NewQueryInvoker[%s, %s](client.queryBus)\n",
			queryDTOType, responseDTOType))
		content.WriteString("\t\tif config.Timeout > 0 {\n")
		content.WriteString("\t\t\tinvoker = invoker.WithTimeout(config.Timeout)\n")
		content.WriteString("\t\t}\n")
		content.WriteString(fmt.Sprintf("\t\tclient.queryInvokers[%q] = invoker\n", g.converter.ToSnakeCase(query.Name)))
		content.WriteString("\t}\n\n")
	}

	content.WriteString("\treturn client, nil\n")
	content.WriteString("}\n\n")

	// Генерация методов для команд
	for _, cmd := range spec.Commands {
		content.WriteString(g.generateCommandMethod(cmd, spec))
		content.WriteString("\n")
	}

	// Генерация методов для запросов
	for _, query := range spec.Queries {
		content.WriteString(g.generateQueryMethod(query, spec))
		content.WriteString("\n")
	}

	content.WriteString("// Close закрывает соединения\n")
	content.WriteString("func (c *Client) Close() error {\n")
	content.WriteString("\tvar errs []error\n")
	content.WriteString("\tfor _, cleanup := range c.cleanup {\n")
	content.WriteString("\t\tif err := cleanup(); err != nil {\n")
	content.WriteString("\t\t\terrs = append(errs, err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}\n")
	content.WriteString("\tif len(errs) > 0 {\n")
	content.WriteString("\t\treturn fmt.Errorf(\"errors during cleanup: %v\", errs)\n")
	content.WriteString("\t}\n")
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n\n")

	// Добавляем обертку для NATS Request-Reply QueryBus
	content.WriteString("// natsRequestReplyQueryBus обертка QueryBus для работы через NATS Request-Reply\n")
	content.WriteString("type natsRequestReplyQueryBus struct {\n")
	content.WriteString("\tadapter    transport.RequestReply\n")
	content.WriteString("\tserializer transport.MessageSerializer\n")
	content.WriteString("\ttimeout    time.Duration\n")
	content.WriteString("}\n\n")

	content.WriteString("func (b *natsRequestReplyQueryBus) Ask(ctx context.Context, q transport.Query) (interface{}, error) {\n")
	content.WriteString("\t// Сериализуем запрос\n")
	content.WriteString("\tdata, err := b.serializer.Serialize(q)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"failed to serialize query: %w\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Формируем subject для запроса\n")
	content.WriteString("\tsubject := fmt.Sprintf(\"queries.%s\", q.QueryName())\n\n")
	content.WriteString("\t// Отправляем запрос через NATS Request-Reply\n")
	content.WriteString("\treply, err := b.adapter.Request(ctx, subject, data, b.timeout)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"request failed: %w\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Возвращаем сырые данные - десериализация будет выполнена в QueryInvoker\n")
	content.WriteString("\t// с правильным типом результата\n")
	content.WriteString("\tvar result map[string]interface{}\n")
	content.WriteString("\tif err := b.serializer.Deserialize(reply.Data, &result); err != nil {\n")
	content.WriteString("\t\t// Если не удалось десериализовать в map, возвращаем как есть\n")
	content.WriteString("\t\treturn reply.Data, nil\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\treturn result, nil\n")
	content.WriteString("}\n\n")

	content.WriteString("func (b *natsRequestReplyQueryBus) Register(handler transport.QueryHandler) error {\n")
	content.WriteString("\t// Регистрация выполняется на стороне сервера\n")
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n")

	path := "pkg/sdk/client.go"
	return g.writer.WriteFile(path, content.String())
}

// generateCommandMethod генерирует метод для команды
func (g *SDKGenerator) generateCommandMethod(cmd CommandSpec, spec *ParsedSpec) string {
	var builder strings.Builder

	methodName := cmd.Name
	cmdDTOType := fmt.Sprintf("%sCommandDTO", cmd.Name)

	// Используем те же функции поиска событий, что и в generateSDKClient
	successEvent := g.findSuccessEvent(cmd, spec)
	errorEvent := g.findErrorEvent(cmd, spec)
	successEventDTO := successEvent + "DTO"
	errorEventDTO := errorEvent + "DTO"

	builder.WriteString(fmt.Sprintf("// %s выполняет команду %s\n", methodName, cmd.Name))
	builder.WriteString(fmt.Sprintf("func (c *Client) %s(ctx context.Context, cmd %s) (%s, error) {\n",
		methodName, cmdDTOType, successEventDTO))

	// Используем DTO напрямую через invoker
	// Используем те же типы событий, что и в invoker
	// Invoke возвращает значение, а не указатель
	builder.WriteString(fmt.Sprintf("\tinvoker := c.commandInvokers[%q].(invoke.CommandInvoker[%s, %s, %s])\n",
		g.converter.ToSnakeCase(cmd.Name), cmdDTOType, successEventDTO, errorEventDTO))
	builder.WriteString("\treturn invoker.Invoke(ctx, cmd)\n")
	builder.WriteString("}\n")

	return builder.String()
}

// generateQueryMethod генерирует метод для запроса
func (g *SDKGenerator) generateQueryMethod(query QuerySpec, spec *ParsedSpec) string {
	var builder strings.Builder

	methodName := query.Name
	queryDTOType := fmt.Sprintf("%sQueryDTO", query.Name)
	responseDTOType := fmt.Sprintf("%sResponseDTO", query.Name)

	builder.WriteString(fmt.Sprintf("// %s выполняет запрос %s\n", methodName, query.Name))
	builder.WriteString(fmt.Sprintf("func (c *Client) %s(ctx context.Context, query %s) (%s, error) {\n",
		methodName, queryDTOType, responseDTOType))

	// Используем DTO напрямую через invoker
	// Invoke возвращает значение, а не указатель
	builder.WriteString(fmt.Sprintf("\tinvoker := c.queryInvokers[%q].(invoke.QueryInvoker[%s, %s])\n",
		g.converter.ToSnakeCase(query.Name), queryDTOType, responseDTOType))
	builder.WriteString("\treturn invoker.Invoke(ctx, query)\n")
	builder.WriteString("}\n")

	return builder.String()
}

// generateSDKConfig генерирует SDK конфигурацию
func (g *SDKGenerator) generateSDKConfig(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `// Code generated by potter-gen. DO NOT EDIT.

package sdk

import "time"

// ClientConfig конфигурация SDK client
type ClientConfig struct {
	CommandTransport string
	QueryTransport  string
	NATSUrl         string
	KafkaBrokers    []string
	RESTBaseURL     string
	GRPCAddress     string
	Timeout         time.Duration
}

// DefaultConfig возвращает конфигурацию по умолчанию
func DefaultConfig() *ClientConfig {
	return &ClientConfig{
		CommandTransport: "NATS",
		QueryTransport:   "NATS",
		NATSUrl:          "nats://localhost:4222",
		KafkaBrokers:     []string{"localhost:9092"},
		RESTBaseURL:      "http://localhost:8080",
		GRPCAddress:      "localhost:50051",
		Timeout:          30 * time.Second,
	}
}
`

	path := "pkg/sdk/config.go"
	return g.writer.WriteFile(path, content)
}

// generateSDKTypes генерирует DTO типы для SDK
func (g *SDKGenerator) generateSDKTypes(spec *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	potterPath := config.PotterImportPath
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	basePotterPath := strings.Split(potterPath, "@")[0]

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package sdk\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"time\"\n")
	content.WriteString(fmt.Sprintf("\t\"%s/framework/events\"\n", basePotterPath))
	content.WriteString(")\n\n")

	// Генерация DTO типов команд
	for _, cmd := range spec.Commands {
		content.WriteString(fmt.Sprintf("// %sCommandDTO DTO для команды %s\n", cmd.Name, cmd.Name))
		content.WriteString(fmt.Sprintf("type %sCommandDTO struct {\n", cmd.Name))

		// Генерация полей из Request сообщения
		if len(cmd.RequestFields) > 0 {
			for _, field := range cmd.RequestFields {
				goType := g.protoToGoTypeDTO(field.Type, field.Repeated, spec)
				fieldName := g.toPublicField(field.Name)
				content.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, g.converter.ToSnakeCase(field.Name)))
			}
		} else {
			content.WriteString("\t// No fields in request message\n")
		}
		content.WriteString("}\n\n")

		// Добавляем метод CommandName() для реализации интерфейса transport.Command
		cmdNameSnake := g.converter.ToSnakeCase(cmd.Name)
		content.WriteString("// CommandName возвращает имя команды для маршрутизации\n")
		content.WriteString(fmt.Sprintf("func (c %sCommandDTO) CommandName() string {\n", cmd.Name))
		content.WriteString(fmt.Sprintf("\treturn %q\n", cmdNameSnake))
		content.WriteString("}\n\n")
	}

	// Генерация DTO типов запросов
	for _, query := range spec.Queries {
		content.WriteString(fmt.Sprintf("// %sQueryDTO DTO для запроса %s\n", query.Name, query.Name))
		content.WriteString(fmt.Sprintf("type %sQueryDTO struct {\n", query.Name))

		// Генерация полей из Request сообщения
		if len(query.RequestFields) > 0 {
			for _, field := range query.RequestFields {
				goType := g.protoToGoTypeDTO(field.Type, field.Repeated, spec)
				fieldName := g.toPublicField(field.Name)
				content.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, g.converter.ToSnakeCase(field.Name)))
			}
		} else {
			content.WriteString("\t// No fields in request message\n")
		}
		content.WriteString("}\n\n")

		// Добавляем метод QueryName() для реализации интерфейса transport.Query
		queryNameSnake := g.converter.ToSnakeCase(query.Name)
		content.WriteString("// QueryName возвращает имя запроса для маршрутизации\n")
		content.WriteString(fmt.Sprintf("func (q %sQueryDTO) QueryName() string {\n", query.Name))
		content.WriteString(fmt.Sprintf("\treturn %q\n", queryNameSnake))
		content.WriteString("}\n\n")

		content.WriteString(fmt.Sprintf("// %sResponseDTO DTO для ответа на запрос %s\n", query.Name, query.Name))
		content.WriteString(fmt.Sprintf("type %sResponseDTO struct {\n", query.Name))

		// Генерация полей из Response сообщения с использованием DTO
		if len(query.ResponseFields) > 0 {
			for _, field := range query.ResponseFields {
				goType := g.protoToGoTypeDTO(field.Type, field.Repeated, spec)
				fieldName := g.toPublicField(field.Name)
				content.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, g.converter.ToSnakeCase(field.Name)))
			}
		} else {
			content.WriteString("\t// No fields in response message\n")
		}
		content.WriteString("}\n\n")
	}

	// Генерация DTO типов событий
	for _, event := range spec.Events {
		content.WriteString(fmt.Sprintf("// %sDTO DTO для события %s\n", event.Name, event.Name))
		content.WriteString(fmt.Sprintf("type %sDTO struct {\n", event.Name))

		// Генерация полей из события с использованием DTO
		if len(event.Fields) > 0 {
			for _, field := range event.Fields {
				goType := g.protoToGoTypeDTO(field.Type, field.Repeated, spec)
				fieldName := g.toPublicField(field.Name)
				content.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, g.converter.ToSnakeCase(field.Name)))
			}
		} else {
			content.WriteString("\t// No fields in event message\n")
		}
		
		// Добавляем поля для реализации интерфейса events.Event
		content.WriteString("\t// Поля для реализации интерфейса events.Event\n")
		content.WriteString("\tEventIDValue     string                 `json:\"event_id,omitempty\"`\n")
		content.WriteString("\tEventTypeValue   string                 `json:\"event_type,omitempty\"`\n")
		content.WriteString("\tOccurredAtValue  time.Time              `json:\"occurred_at,omitempty\"`\n")
		content.WriteString("\tAggregateIDValue string                 `json:\"aggregate_id,omitempty\"`\n")
		content.WriteString("\tMetadataValue    map[string]interface{} `json:\"metadata,omitempty\"`\n")
		content.WriteString("}\n\n")
		
		// Добавляем методы для реализации интерфейса events.Event
		eventTypeSnake := g.converter.ToSnakeCase(event.Name)
		if event.EventType != "" {
			eventTypeSnake = event.EventType
		}
		
		content.WriteString(fmt.Sprintf("// EventID возвращает уникальный идентификатор события\n"))
		content.WriteString(fmt.Sprintf("func (e %sDTO) EventID() string {\n", event.Name))
		content.WriteString("\tif e.EventIDValue == \"\" {\n")
		// В сгенерированном коде нужно использовать %d
		// При записи через WriteString нужно экранировать % как %%
		content.WriteString("\t\treturn fmt.Sprintf(\"event-%%d\", time.Now().UnixNano())\n")
		content.WriteString("\t}\n")
		content.WriteString("\treturn e.EventIDValue\n")
		content.WriteString("}\n\n")
		
		content.WriteString(fmt.Sprintf("// EventType возвращает тип события\n"))
		content.WriteString(fmt.Sprintf("func (e %sDTO) EventType() string {\n", event.Name))
		content.WriteString(fmt.Sprintf("\tif e.EventTypeValue == \"\" {\n"))
		content.WriteString(fmt.Sprintf("\t\treturn %q\n", eventTypeSnake))
		content.WriteString("\t}\n")
		content.WriteString("\treturn e.EventTypeValue\n")
		content.WriteString("}\n\n")
		
		content.WriteString(fmt.Sprintf("// OccurredAt возвращает время возникновения события\n"))
		content.WriteString(fmt.Sprintf("func (e %sDTO) OccurredAt() time.Time {\n", event.Name))
		content.WriteString("\tif e.OccurredAtValue.IsZero() {\n")
		content.WriteString("\t\treturn time.Now()\n")
		content.WriteString("\t}\n")
		content.WriteString("\treturn e.OccurredAtValue\n")
		content.WriteString("}\n\n")
		
		content.WriteString(fmt.Sprintf("// AggregateID возвращает идентификатор агрегата\n"))
		content.WriteString(fmt.Sprintf("func (e %sDTO) AggregateID() string {\n", event.Name))
		content.WriteString("\treturn e.AggregateIDValue\n")
		content.WriteString("}\n\n")
		
		content.WriteString(fmt.Sprintf("// Metadata возвращает метаданные события\n"))
		content.WriteString(fmt.Sprintf("func (e %sDTO) Metadata() events.EventMetadata {\n", event.Name))
		content.WriteString("\tif e.MetadataValue == nil {\n")
		content.WriteString("\t\treturn make(events.EventMetadata)\n")
		content.WriteString("\t}\n")
		content.WriteString("\treturn events.EventMetadata(e.MetadataValue)\n")
		content.WriteString("}\n\n")
		
		// Если это событие ошибки, добавляем методы для интерфейса invoke.ErrorEvent
		if event.IsError {
			errorCodeValue := event.ErrorCode
			if errorCodeValue == "" {
				errorCodeValue = strings.ToUpper(g.converter.ToSnakeCase(event.Name))
			}
			
			content.WriteString(fmt.Sprintf("// Error возвращает ошибку, связанную с событием\n"))
			content.WriteString(fmt.Sprintf("func (e %sDTO) Error() error {\n", event.Name))
			// Проверяем наличие полей Reason и Details
			hasReason := false
			hasDetails := false
			for _, field := range event.Fields {
				if strings.ToLower(field.Name) == "reason" {
					hasReason = true
				}
				if strings.ToLower(field.Name) == "details" {
					hasDetails = true
				}
			}
			if hasReason && hasDetails {
				content.WriteString("\tif e.Reason != \"\" || e.Details != \"\" {\n")
				// Используем правильное экранирование для fmt.Errorf в сгенерированном коде
				// %%s в строке генератора становится %s в сгенерированном коде
				content.WriteString("\t\treturn fmt.Errorf(\"%%s: %%s - %%s\", e.Reason, e.Details)\n")
				content.WriteString("\t}\n")
			} else if hasReason {
				content.WriteString("\tif e.Reason != \"\" {\n")
				content.WriteString("\t\treturn fmt.Errorf(\"%%s\", e.Reason)\n")
				content.WriteString("\t}\n")
			} else if hasDetails {
				content.WriteString("\tif e.Details != \"\" {\n")
				content.WriteString("\t\treturn fmt.Errorf(\"%%s\", e.Details)\n")
				content.WriteString("\t}\n")
			}
			content.WriteString(fmt.Sprintf("\treturn fmt.Errorf(%q)\n", errorCodeValue))
			content.WriteString("}\n\n")
			
			content.WriteString(fmt.Sprintf("// ErrorCode возвращает код ошибки\n"))
			content.WriteString(fmt.Sprintf("func (e %sDTO) ErrorCode() string {\n", event.Name))
			if event.ErrorCode != "" {
				content.WriteString(fmt.Sprintf("\treturn %q\n", event.ErrorCode))
			} else {
				content.WriteString(fmt.Sprintf("\treturn %q\n", strings.ToUpper(g.converter.ToSnakeCase(event.Name))))
			}
			content.WriteString("}\n\n")
			
			content.WriteString(fmt.Sprintf("// ErrorMessage возвращает сообщение об ошибке\n"))
			content.WriteString(fmt.Sprintf("func (e %sDTO) ErrorMessage() string {\n", event.Name))
			content.WriteString("\tif e.Reason != \"\" {\n")
			content.WriteString("\t\treturn e.Reason\n")
			content.WriteString("\t}\n")
			content.WriteString("\tif e.Details != \"\" {\n")
			content.WriteString("\t\treturn e.Details\n")
			content.WriteString("\t}\n")
			content.WriteString("\treturn \"\"\n")
			content.WriteString("}\n\n")
			
			content.WriteString(fmt.Sprintf("// IsRetryable указывает, можно ли повторить операцию\n"))
			content.WriteString(fmt.Sprintf("func (e %sDTO) IsRetryable() bool {\n", event.Name))
			content.WriteString(fmt.Sprintf("\treturn %v\n", event.Retryable))
			content.WriteString("}\n\n")
			
			content.WriteString(fmt.Sprintf("// OriginalCommand возвращает исходную команду, вызвавшую ошибку\n"))
			content.WriteString(fmt.Sprintf("func (e %sDTO) OriginalCommand() interface{} {\n", event.Name))
			content.WriteString("\treturn nil\n")
			content.WriteString("}\n\n")
		}
	}

	// Генерация DTO для агрегатов (если используются в Response)
	aggregateDTOs := make(map[string]bool)
	for _, query := range spec.Queries {
		for _, field := range query.ResponseFields {
			if g.isCustomType(field.Type) && g.isAggregateType(spec, field.Type) {
				aggregateDTOs[field.Type] = true
			}
		}
	}

	for aggName := range aggregateDTOs {
		// Находим агрегат в спецификации
		var aggSpec *AggregateSpec
		for i := range spec.Aggregates {
			if spec.Aggregates[i].Name == aggName {
				aggSpec = &spec.Aggregates[i]
				break
			}
		}

		if aggSpec != nil {
			content.WriteString(fmt.Sprintf("// %sDTO DTO для агрегата %s\n", aggName, aggName))
			content.WriteString(fmt.Sprintf("type %sDTO struct {\n", aggName))

			// Генерация полей из агрегата
			if len(aggSpec.Fields) > 0 {
				for _, field := range aggSpec.Fields {
					goType := g.protoToGoTypeDTO(field.Type, field.Repeated, spec)
					fieldName := g.toPublicField(field.Name)
					content.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, g.converter.ToSnakeCase(field.Name)))
				}
			}
			// Добавляем стандартные поля для агрегата
			content.WriteString("\tCreatedAt string `json:\"created_at\"`\n")
			content.WriteString("\tUpdatedAt string `json:\"updated_at\"`\n")
			content.WriteString("}\n\n")
		}
	}

	path := "pkg/sdk/dto.go"
	return g.writer.WriteFile(path, content.String())
}

// generateSDKExamples генерирует примеры использования SDK
func (g *SDKGenerator) generateSDKExamples(spec *ParsedSpec, config *GeneratorConfig) error {
	sdkModulePath := config.ModulePath + "/pkg/sdk"
	
	// Получаем первую команду для примера
	var exampleCmd CommandSpec
	var cmdDTOType string
	if len(spec.Commands) > 0 {
		exampleCmd = spec.Commands[0]
		cmdDTOType = fmt.Sprintf("%sCommandDTO", exampleCmd.Name)
	} else {
		// Если нет команд, используем заглушку
		exampleCmd = CommandSpec{Name: "ExampleCommand"}
		cmdDTOType = "ExampleCommandDTO"
	}
	
	// basic_usage.go
	basicContent := fmt.Sprintf(`// Code generated by potter-gen. DO NOT EDIT.

package examples

import (
	"context"
	"fmt"

	"%s"
)

// ExampleBasicUsage демонстрирует базовое использование SDK
func ExampleBasicUsage() {
	config := sdk.DefaultConfig()
	config.NATSUrl = "nats://localhost:4222"

	client, err := sdk.NewClient(config)
	if err != nil {
		panic(err)
	}
	defer client.Close()

	ctx := context.Background()

	// Пример выполнения команды
`, sdkModulePath)
	
	if len(spec.Commands) > 0 {
		basicContent += fmt.Sprintf(`	event, err := client.%s(ctx, sdk.%s{
		// Add command fields
	})
	if err != nil {
		fmt.Printf("Error: %%v\n", err)
		return
	}

	fmt.Printf("Event: %%+v\n", event)
}
`, exampleCmd.Name, cmdDTOType)
	} else {
		basicContent += `	// Use client methods here
	_ = ctx
}
`
	}

	if err := g.writer.WriteFile("pkg/sdk/examples/basic_usage.go", basicContent); err != nil {
		return err
	}

	// with_nats.go
	natsContent := fmt.Sprintf(`// Code generated by potter-gen. DO NOT EDIT.

package examples

import (
	"context"
	"%s"
)

// ExampleWithNATS демонстрирует использование SDK с NATS
func ExampleWithNATS() {
	config := sdk.DefaultConfig()
	config.CommandTransport = "NATS"
	config.QueryTransport = "NATS"
	config.NATSUrl = "nats://localhost:4222"

	client, _ := sdk.NewClient(config)
	defer client.Close()

	ctx := context.Background()
	_ = ctx
	// Use client methods
}
`, sdkModulePath)

	if err := g.writer.WriteFile("pkg/sdk/examples/with_nats.go", natsContent); err != nil {
		return err
	}

	// with_rest.go
	restContent := fmt.Sprintf(`// Code generated by potter-gen. DO NOT EDIT.

package examples

import (
	"context"
	"%s"
)

// ExampleWithREST демонстрирует использование SDK с REST
func ExampleWithREST() {
	config := sdk.DefaultConfig()
	config.QueryTransport = "REST"
	config.RESTBaseURL = "http://localhost:8080"

	client, _ := sdk.NewClient(config)
	defer client.Close()

	ctx := context.Background()
	_ = ctx
	// Use client methods
}
`, sdkModulePath)

	return g.writer.WriteFile("pkg/sdk/examples/with_rest.go", restContent)
}

// generateSDKGoMod генерирует go.mod для SDK
func (g *SDKGenerator) generateSDKGoMod(_ *ParsedSpec, config *GeneratorConfig) error {
	// SDK модуль использует тот же module path, но находится в pkg/sdk
	// Это позволяет импортировать SDK как config.ModulePath/pkg/sdk
	sdkModulePath := config.ModulePath + "/pkg/sdk"

	// Определяем версию Go из основного go.mod или используем минимальную поддерживаемую
	goVersion := g.detectGoVersion(config.OutputDir)
	// Проверяем, что версия валидна (не пустая и не слишком новая)
	if goVersion == "" || !g.isValidGoVersion(goVersion) {
		// Используем минимальную поддерживаемую версию Go для SDK
		goVersion = "1.21"
	}

	// Для SDK требуется основной модуль potter из main ветки репозитория
	// go get будет выполнен автоматически после генерации go.mod
	content := fmt.Sprintf(`module %s

go %s
`, sdkModulePath, goVersion)

	if err := g.writer.WriteFile("pkg/sdk/go.mod", content); err != nil {
		return err
	}

	return nil
}

// runGoGetPotter выполняет go get для получения potter framework из main ветки
func (g *SDKGenerator) runGoGetPotter(config *GeneratorConfig) error {
	sdkDir := filepath.Join(config.OutputDir, "pkg", "sdk")
	
	// Проверяем, существует ли директория SDK
	if _, err := os.Stat(sdkDir); os.IsNotExist(err) {
		return fmt.Errorf("SDK directory does not exist: %s", sdkDir)
	}

	potterPath := config.PotterImportPath
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	basePotterPath := strings.Split(potterPath, "@")[0]

	// Выполняем go get для получения potter framework из main ветки
	cmd := exec.Command("go", "get", fmt.Sprintf("%s@main", basePotterPath))
	cmd.Dir = sdkDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	if err := cmd.Run(); err != nil {
		// Не прерываем генерацию, если go get не удался
		// Это может произойти, если репозиторий недоступен или нет сети
		return fmt.Errorf("failed to run go get %s@main (this is not critical, you can run it manually later): %w", basePotterPath, err)
	}

	// Выполняем go mod tidy для добавления всех транзитивных зависимостей в go.sum
	cmdTidy := exec.Command("go", "mod", "tidy")
	cmdTidy.Dir = sdkDir
	cmdTidy.Stdout = os.Stdout
	cmdTidy.Stderr = os.Stderr
	
	if err := cmdTidy.Run(); err != nil {
		// Не прерываем генерацию, если go mod tidy не удался
		return fmt.Errorf("failed to run go mod tidy (this is not critical, you can run it manually later): %w", err)
	}

	return nil
}

// detectGoVersion определяет версию Go из go.mod файла в outputDir или родительских директориях
func (g *SDKGenerator) detectGoVersion(outputDir string) string {
	// Ищем go.mod в outputDir и родительских директориях
	dirs := []string{outputDir}
	
	// Добавляем родительские директории (до 5 уровней вверх)
	currentDir := outputDir
	for i := 0; i < 5; i++ {
		parentDir := filepath.Dir(currentDir)
		if parentDir == currentDir {
			break
		}
		dirs = append(dirs, parentDir)
		currentDir = parentDir
	}

	// Ищем go.mod файл
	for _, dir := range dirs {
		goModPath := filepath.Join(dir, "go.mod")
		if data, err := os.ReadFile(goModPath); err == nil {
			// Парсим версию Go из go.mod
			lines := strings.Split(string(data), "\n")
			for _, line := range lines {
				line = strings.TrimSpace(line)
				if strings.HasPrefix(line, "go ") {
					parts := strings.Fields(line)
					if len(parts) >= 2 {
						return parts[1]
					}
				}
			}
		}
	}

	return ""
}

// isValidGoVersion проверяет, является ли версия Go валидной
// Принимает версии вида 1.21, 1.22, 1.23 и т.д.
// Версии выше 1.23 считаются невалидными, так как они могут быть несуществующими
func (g *SDKGenerator) isValidGoVersion(version string) bool {
	// Проверяем формат версии (должна начинаться с "1.")
	if !strings.HasPrefix(version, "1.") {
		return false
	}
	// Парсим версию
	parts := strings.Split(version, ".")
	if len(parts) < 2 {
		return false
	}
	
	// Извлекаем минорную версию (например, "25" из "1.25.0")
	minorStr := parts[1]
	// Убираем возможные суффиксы типа "1.25.0" -> "25"
	if idx := strings.Index(minorStr, "."); idx > 0 {
		minorStr = minorStr[:idx]
	}
	
	// Проверяем, что минорная версия в разумных пределах
	// Версии Go обычно идут последовательно: 1.21, 1.22, 1.23, ...
	// Версии выше 1.23 могут быть несуществующими (например, 1.25.0 не существует)
	// Используем простую проверку: если минорная версия больше 23, считаем невалидной
	if len(minorStr) == 2 {
		// Двузначные версии: проверяем, что первая цифра не больше 2
		if minorStr[0] > '2' {
			return false
		}
		// Если первая цифра 2, вторая должна быть не больше 3
		if minorStr[0] == '2' && minorStr[1] > '3' {
			return false
		}
	} else if len(minorStr) > 2 {
		// Версии с более чем двумя цифрами считаем невалидными
		return false
	}
	
	return true
}

// calculatePotterRelativePath вычисляет относительный путь от SDK директории к potter framework
func (g *SDKGenerator) calculatePotterRelativePath(outputDir string) string {
	// SDK находится в outputDir/pkg/sdk
	sdkDir := filepath.Join(outputDir, "pkg", "sdk")
	
	// Ищем potter framework в родительских директориях от outputDir
	// Проверяем наличие go.mod с модулем github.com/akriventsev/potter
	currentDir := outputDir
	for i := 0; i < 10; i++ {
		goModPath := filepath.Join(currentDir, "go.mod")
		if data, err := os.ReadFile(goModPath); err == nil {
			// Проверяем, содержит ли go.mod модуль potter
			content := string(data)
			if strings.Contains(content, "module github.com/akriventsev/potter") {
				// Нашли potter framework, вычисляем относительный путь
				relPath, err := filepath.Rel(sdkDir, currentDir)
				if err == nil && relPath != "." {
					// Нормализуем путь для использования в go.mod (используем прямые слеши)
					normalized := filepath.ToSlash(relPath)
					// Убираем "./" в начале, если есть
					normalized = strings.TrimPrefix(normalized, "./")
					// Убираем "/." в конце, если есть
					normalized = strings.TrimSuffix(normalized, "/.")
					// Убираем "/" в конце, если есть
					normalized = strings.TrimSuffix(normalized, "/")
					// Убираем "." в конце, если есть (может быть несколько)
					for strings.HasSuffix(normalized, ".") && len(normalized) > 1 {
						normalized = strings.TrimSuffix(normalized, ".")
					}
					// Если путь пустой или равен ".", используем стандартный путь
					if normalized == "" || normalized == "." {
						return "../../../../.."
					}
					// Проверяем, что путь начинается с ".." (относительный путь вверх)
					if !strings.HasPrefix(normalized, "..") {
						// Если путь не начинается с "..", возможно это абсолютный путь
						// В этом случае используем стандартный путь
						return "../../../../.."
					}
					// Подсчитываем количество уровней вверх
					levels := strings.Count(normalized, "../")
					if levels < 5 {
						// Если уровней меньше 5, добавляем недостающие
						additionalLevels := 5 - levels
						for i := 0; i < additionalLevels; i++ {
							normalized = "../" + normalized
						}
					}
					return normalized
				}
			}
		}
		
		// Переходим на уровень выше
		parentDir := filepath.Dir(currentDir)
		if parentDir == currentDir {
			// Достигли корня файловой системы
			break
		}
		currentDir = parentDir
	}
	
	// Если не нашли, вычисляем стандартный путь
	// SDK находится в outputDir/pkg/sdk, нужно подняться до potter root
	// Подсчитываем количество уровней от SDK до outputDir, затем добавляем уровни до potter
	relToOutput, err := filepath.Rel(sdkDir, outputDir)
	if err == nil {
		// От outputDir нужно подняться до potter root
		// Обычно это 5 уровней вверх от SDK: pkg/sdk -> generated -> codegen -> examples -> potter
		// Но лучше вычислить динамически
		parts := strings.Split(filepath.ToSlash(relToOutput), "/")
		levelsUp := len(parts) + 5 // SDK -> pkg -> outputDir -> ... -> potter
		pathParts := make([]string, levelsUp)
		for i := 0; i < levelsUp; i++ {
			pathParts[i] = ".."
		}
		return strings.Join(pathParts, "/")
	}
	
	// Fallback: используем стандартный относительный путь (5 уровней вверх)
	return "../../../../.."
}

// generateSDKREADME генерирует README для SDK
func (g *SDKGenerator) generateSDKREADME(_ *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	sdkModulePath := config.ModulePath + "-sdk"
	content.WriteString(fmt.Sprintf("# %s\n\n", sdkModulePath))
	content.WriteString("Type-safe SDK для интеграции с сервисом.\n\n")
	content.WriteString("## Установка\n\n")
	content.WriteString(fmt.Sprintf("```bash\ngo get %s\n```\n\n", sdkModulePath))
	content.WriteString("## Использование\n\n")
	content.WriteString("```go\n")
	content.WriteString("import \"example-sdk\"\n\n")
	content.WriteString("config := sdk.DefaultConfig()\n")
	content.WriteString("config.NATSUrl = \"nats://localhost:4222\"\n")
	content.WriteString("client, _ := sdk.NewClient(config)\n")
	content.WriteString("defer client.Close()\n\n")
	content.WriteString("event, err := client.CreateItem(ctx, sdk.CreateItemCommand{\n")
	content.WriteString("\t// Add fields\n")
	content.WriteString("})\n")
	content.WriteString("```\n\n")
	content.WriteString("## Примеры\n\n")
	content.WriteString("См. `examples/` для примеров использования.\n\n")

	return g.writer.WriteFile("pkg/sdk/README.md", content.String())
}

// findSuccessEvent находит событие успеха для команды
func (g *SDKGenerator) findSuccessEvent(cmd CommandSpec, spec *ParsedSpec) string {
	cmdNameLower := strings.ToLower(cmd.Name)
	aggNameLower := strings.ToLower(cmd.Aggregate)
	
	// Сначала ищем событие по паттерну имени команды
	// CreateItem -> ItemCreatedEvent
	// UpdateItem -> ItemUpdatedEvent или ItemCreatedEvent
	for _, event := range spec.Events {
		if !event.IsError {
			eventNameLower := strings.ToLower(event.Name)
			// Проверяем различные паттерны:
			// CreateItem -> ItemCreatedEvent (содержит "item" и "created")
			// UpdateItem -> ItemUpdatedEvent (содержит "item" и "updated")
			if strings.Contains(eventNameLower, aggNameLower) {
				// Для CreateItem ищем "created"
				if strings.Contains(cmdNameLower, "create") && strings.Contains(eventNameLower, "created") {
				return event.Name
			}
				// Для UpdateItem ищем "updated"
				if strings.Contains(cmdNameLower, "update") && strings.Contains(eventNameLower, "updated") {
					return event.Name
				}
				// Для DeleteItem ищем "deleted"
				if strings.Contains(cmdNameLower, "delete") && strings.Contains(eventNameLower, "deleted") {
					return event.Name
				}
			}
		}
	}
	
	// Если не найдено по паттерну команды, ищем любое событие для агрегата
	for _, event := range spec.Events {
		if !event.IsError {
			if strings.Contains(strings.ToLower(event.Name), aggNameLower) {
				return event.Name
			}
		}
	}
	
	// Если не найдено, генерируем имя по паттерну
	return fmt.Sprintf("%sCreatedEvent", cmd.Aggregate)
}

// findErrorEvent находит событие ошибки для команды
func (g *SDKGenerator) findErrorEvent(cmd CommandSpec, spec *ParsedSpec) string {
	// Ищем событие ошибки по имени команды или агрегата
	cmdNameLower := strings.ToLower(cmd.Name)
	aggNameLower := strings.ToLower(cmd.Aggregate)

	// Сначала ищем точное совпадение по имени команды
	// CreateItem -> CreateItemFailedEvent или CreateItemErrorEvent
	for _, event := range spec.Events {
		if event.IsError {
			eventNameLower := strings.ToLower(event.Name)
			// Точное совпадение: CreateItem -> CreateItemFailedEvent
			if strings.Contains(eventNameLower, cmdNameLower+"failed") ||
				strings.Contains(eventNameLower, cmdNameLower+"error") {
				return event.Name
			}
		}
	}

	// Затем ищем по агрегату с учетом различных паттернов:
	// CreateItem (Item) -> ItemCreationFailedEvent
	// UpdateItem (Item) -> ItemUpdateFailedEvent или ItemCreationFailedEvent
	// DeleteItem (Item) -> ItemDeletionFailedEvent или ItemCreationFailedEvent
	for _, event := range spec.Events {
		if event.IsError {
			eventNameLower := strings.ToLower(event.Name)
			// Ищем события вида {Aggregate}CreationFailedEvent, {Aggregate}UpdateFailedEvent, {Aggregate}FailedEvent
			// Проверяем различные варианты: ItemCreationFailedEvent содержит "item" и "creationfailed"
			if strings.Contains(eventNameLower, aggNameLower) {
				// Проверяем различные паттерны ошибок
				if strings.Contains(eventNameLower, "creationfailed") ||
					strings.Contains(eventNameLower, "updatefailed") ||
					strings.Contains(eventNameLower, "deletionfailed") ||
					strings.Contains(eventNameLower, "failed") ||
					strings.Contains(eventNameLower, "error") {
					return event.Name
				}
			}
			// Также проверяем паттерны вида {Aggregate}FailedEvent или {Aggregate}ErrorEvent
			if strings.HasPrefix(eventNameLower, aggNameLower) &&
				(strings.HasSuffix(eventNameLower, "failed") ||
					strings.HasSuffix(eventNameLower, "error") ||
					strings.Contains(eventNameLower, "failed") ||
					strings.Contains(eventNameLower, "error")) {
				return event.Name
			}
		}
	}

	// Если не найдено, генерируем имя по паттерну
	return fmt.Sprintf("%sFailedEvent", cmd.Name)
}

// getEventType возвращает тип события (eventType) для использования в EventAwaiter
func (g *SDKGenerator) getEventType(eventName string, cmd CommandSpec, spec *ParsedSpec) string {
	// Ищем событие в спецификации
	for _, event := range spec.Events {
		if event.Name == eventName {
			if event.EventType != "" {
				return event.EventType
			}
			// Генерируем eventType из имени события в snake_case
			return g.converter.ToSnakeCase(eventName)
		}
	}
	// Если не найдено, генерируем по паттерну
	if strings.Contains(eventName, "Created") {
		return fmt.Sprintf("%s.created", g.converter.ToSnakeCase(cmd.Aggregate))
	}
	if strings.Contains(eventName, "Failed") || strings.Contains(eventName, "Error") {
		// Для событий ошибок используем snake_case имени события с суффиксом .failed
		eventNameSnake := g.converter.ToSnakeCase(eventName)
		if !strings.HasSuffix(eventNameSnake, ".failed") {
			return eventNameSnake + ".failed"
		}
		return eventNameSnake
	}
	return g.converter.ToSnakeCase(eventName)
}

// protoToGoTypeDTO конвертирует proto тип в Go тип для DTO
func (g *SDKGenerator) protoToGoTypeDTO(protoType string, repeated bool, spec *ParsedSpec) string {
	var goType string
	switch protoType {
	case "string":
		goType = "string"
	case "int32":
		goType = "int32"
	case "int64":
		goType = "int64"
	case "bool":
		goType = "bool"
	case "float64":
		goType = "float64"
	case "float32":
		goType = "float32"
	case "[]byte":
		goType = "[]byte"
	default:
		// Для пользовательских типов используем DTO
		if g.isCustomType(protoType) && g.isAggregateType(spec, protoType) {
			goType = protoType + "DTO"
		} else {
			// Для других пользовательских типов используем как есть (будут созданы DTO)
			goType = protoType + "DTO"
		}
	}

	// Если поле repeated, добавляем слайс
	if repeated {
		return "[]" + goType
	}
	return goType
}

// isCustomType проверяет, является ли тип пользовательским (не базовым типом)
func (g *SDKGenerator) isCustomType(protoType string) bool {
	basicTypes := map[string]bool{
		"string":  true,
		"int32":   true,
		"int64":   true,
		"bool":    true,
		"float64": true,
		"float32": true,
		"[]byte":  true,
	}
	return !basicTypes[protoType]
}

// isAggregateType проверяет, является ли тип агрегатом
func (g *SDKGenerator) isAggregateType(spec *ParsedSpec, protoType string) bool {
	for _, agg := range spec.Aggregates {
		if agg.Name == protoType {
			return true
		}
	}
	return false
}

// toPublicField конвертирует имя поля в публичное (с заглавной буквы)
func (g *SDKGenerator) toPublicField(name string) string {
	if len(name) == 0 {
		return name
	}
	// Конвертируем snake_case в CamelCase
	parts := strings.Split(name, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]) + part[1:])
		}
	}
	return result.String()
}
