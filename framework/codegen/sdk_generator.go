package codegen

import (
	"fmt"
	"strings"
)

// SDKGenerator генератор SDK
type SDKGenerator struct {
	*BaseGenerator
}

// NewSDKGenerator создает новый генератор SDK
func NewSDKGenerator(outputDir string) *SDKGenerator {
	return &SDKGenerator{
		BaseGenerator: NewBaseGenerator("sdk", outputDir),
	}
}

// Generate генерирует SDK
func (g *SDKGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateSDKClient(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK client: %w", err)
	}

	if err := g.generateSDKConfig(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK config: %w", err)
	}

	if err := g.generateSDKTypes(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK types: %w", err)
	}

	if err := g.generateSDKExamples(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK examples: %w", err)
	}

	if err := g.generateSDKGoMod(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK go.mod: %w", err)
	}

	if err := g.generateSDKREADME(spec, config); err != nil {
		return fmt.Errorf("failed to generate SDK README: %w", err)
	}

	return nil
}

// generateSDKClient генерирует SDK client
func (g *SDKGenerator) generateSDKClient(spec *ParsedSpec, _ *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package sdk\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"time\"\n")
	content.WriteString("\n")
	content.WriteString("\t\"potter/framework/adapters/messagebus\"\n")
	content.WriteString("\t\"potter/framework/invoke\"\n")
	content.WriteString("\t\"potter/framework/transport\"\n")
	content.WriteString(")\n\n")

	content.WriteString("// Client SDK client для интеграции\n")
	content.WriteString("type Client struct {\n")
	content.WriteString("\tcommandInvokers map[string]interface{}\n")
	content.WriteString("\tqueryInvokers   map[string]interface{}\n")
	content.WriteString("\tconfig          *ClientConfig\n")
	content.WriteString("\tcommandBus      *invoke.AsyncCommandBus\n")
	content.WriteString("\tqueryBus        transport.QueryBus\n")
	content.WriteString("\teventAwaiter    *invoke.EventAwaiter\n")
	content.WriteString("\tcleanup         []func() error\n")
	content.WriteString("}\n\n")

	content.WriteString("// NewClient создает новый SDK client\n")
	content.WriteString("func NewClient(config *ClientConfig) (*Client, error) {\n")
	content.WriteString("\tctx := context.Background()\n")
	content.WriteString("\tclient := &Client{\n")
	content.WriteString("\t\tcommandInvokers: make(map[string]interface{}),\n")
	content.WriteString("\t\tqueryInvokers:   make(map[string]interface{}),\n")
	content.WriteString("\t\tconfig:          config,\n")
	content.WriteString("\t\tcleanup:         make([]func() error, 0),\n")
	content.WriteString("\t}\n\n")

	// Настройка транспортов
	content.WriteString("\t// Настройка транспортов\n")
	content.WriteString("\tvar commandPublisher transport.Publisher\n")
	content.WriteString("\tvar queryRequestReply transport.RequestReply\n")
	content.WriteString("\tvar eventSubscriber transport.Subscriber\n\n")

	// NATS транспорт для команд
	content.WriteString("\tif config.CommandTransport == \"NATS\" {\n")
	content.WriteString("\t\tnatsAdapter, err := messagebus.NewNATSAdapter(config.NATSUrl)\n")
	content.WriteString("\t\tif err != nil {\n")
	content.WriteString("\t\t\treturn nil, fmt.Errorf(\"failed to create NATS adapter: %w\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif err := natsAdapter.Start(ctx); err != nil {\n")
	content.WriteString("\t\t\treturn nil, fmt.Errorf(\"failed to start NATS adapter: %w\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tclient.cleanup = append(client.cleanup, func() error { return natsAdapter.Stop(ctx) })\n")
	content.WriteString("\t\tcommandPublisher = natsAdapter\n")
	content.WriteString("\t\tqueryRequestReply = natsAdapter\n")
	content.WriteString("\t\teventSubscriber = natsAdapter\n")
	content.WriteString("\t}\n\n")

	// Создание AsyncCommandBus
	content.WriteString("\t// Создание AsyncCommandBus\n")
	content.WriteString("\tif commandPublisher != nil {\n")
	content.WriteString("\t\tclient.commandBus = invoke.NewAsyncCommandBus(commandPublisher)\n")
	content.WriteString("\t}\n\n")

	// Создание QueryBus через NATS Request-Reply
	content.WriteString("\t// Создание QueryBus через NATS Request-Reply\n")
	content.WriteString("\tif queryRequestReply != nil {\n")
	content.WriteString("\t\t// Используем обертку для Request-Reply как QueryBus\n")
	content.WriteString("\t\tclient.queryBus = &natsRequestReplyQueryBus{\n")
	content.WriteString("\t\t\tadapter:    queryRequestReply,\n")
	content.WriteString("\t\t\tserializer: invoke.NewJSONSerializer(),\n")
	content.WriteString("\t\t\ttimeout:    config.Timeout,\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}\n\n")

	// Создание EventAwaiter
	content.WriteString("\t// Создание EventAwaiter\n")
	content.WriteString("\tif eventSubscriber != nil {\n")
	content.WriteString("\t\tresolver := invoke.NewDefaultSubjectResolver(\"commands\", \"events\")\n")
	content.WriteString("\t\tclient.eventAwaiter = invoke.NewEventAwaiterFromTransport(\n")
	content.WriteString("\t\t\teventSubscriber,\n")
	content.WriteString("\t\t\tinvoke.NewJSONSerializer(),\n")
	content.WriteString("\t\t\tresolver,\n")
	content.WriteString("\t\t)\n")
	content.WriteString("\t}\n\n")

	// Заполнение commandInvokers
	content.WriteString("\t// Заполнение commandInvokers\n")
	for _, cmd := range spec.Commands {
		cmdType := fmt.Sprintf("%sCommand", cmd.Name)
		successEvent := g.findSuccessEvent(cmd, spec)
		errorEvent := g.findErrorEvent(cmd, spec)

		content.WriteString(fmt.Sprintf("\t// %s command invoker\n", cmd.Name))
		content.WriteString("\tif client.commandBus != nil && client.eventAwaiter != nil {\n")
		content.WriteString(fmt.Sprintf("\t\tinvoker := invoke.NewCommandInvoker[%s, %s, %s](\n",
			cmdType, successEvent, errorEvent))
		content.WriteString("\t\t\tclient.commandBus,\n")
		content.WriteString("\t\t\tclient.eventAwaiter,\n")
		content.WriteString(fmt.Sprintf("\t\t\t%q,\n", g.getEventType(successEvent, cmd, spec)))
		content.WriteString(fmt.Sprintf("\t\t\t%q,\n", g.getEventType(errorEvent, cmd, spec)))
		content.WriteString("\t\t)\n")
		content.WriteString("\t\tif config.Timeout > 0 {\n")
		content.WriteString("\t\t\tinvoker = invoker.WithTimeout(config.Timeout)\n")
		content.WriteString("\t\t}\n")
		content.WriteString(fmt.Sprintf("\t\tclient.commandInvokers[%q] = invoker\n", g.converter.ToSnakeCase(cmd.Name)))
		content.WriteString("\t}\n\n")
	}

	// Заполнение queryInvokers
	content.WriteString("\t// Заполнение queryInvokers\n")
	for _, query := range spec.Queries {
		queryType := fmt.Sprintf("%sQuery", query.Name)
		responseType := fmt.Sprintf("%sResponse", query.Name)

		content.WriteString(fmt.Sprintf("\t// %s query invoker\n", query.Name))
		content.WriteString("\tif client.queryBus != nil {\n")
		content.WriteString(fmt.Sprintf("\t\tinvoker := invoke.NewQueryInvoker[%s, %s](client.queryBus)\n",
			queryType, responseType))
		content.WriteString("\t\tif config.Timeout > 0 {\n")
		content.WriteString("\t\t\tinvoker = invoker.WithTimeout(config.Timeout)\n")
		content.WriteString("\t\t}\n")
		content.WriteString(fmt.Sprintf("\t\tclient.queryInvokers[%q] = invoker\n", g.converter.ToSnakeCase(query.Name)))
		content.WriteString("\t}\n\n")
	}

	content.WriteString("\treturn client, nil\n")
	content.WriteString("}\n\n")

	// Генерация методов для команд
	for _, cmd := range spec.Commands {
		content.WriteString(g.generateCommandMethod(cmd, spec))
		content.WriteString("\n")
	}

	// Генерация методов для запросов
	for _, query := range spec.Queries {
		content.WriteString(g.generateQueryMethod(query, spec))
		content.WriteString("\n")
	}

	content.WriteString("// Close закрывает соединения\n")
	content.WriteString("func (c *Client) Close() error {\n")
	content.WriteString("\tvar errs []error\n")
	content.WriteString("\tfor _, cleanup := range c.cleanup {\n")
	content.WriteString("\t\tif err := cleanup(); err != nil {\n")
	content.WriteString("\t\t\terrs = append(errs, err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}\n")
	content.WriteString("\tif len(errs) > 0 {\n")
	content.WriteString("\t\treturn fmt.Errorf(\"errors during cleanup: %v\", errs)\n")
	content.WriteString("\t}\n")
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n\n")

	// Добавляем обертку для NATS Request-Reply QueryBus
	content.WriteString("// natsRequestReplyQueryBus обертка QueryBus для работы через NATS Request-Reply\n")
	content.WriteString("type natsRequestReplyQueryBus struct {\n")
	content.WriteString("\tadapter    transport.RequestReply\n")
	content.WriteString("\tserializer transport.MessageSerializer\n")
	content.WriteString("\ttimeout    time.Duration\n")
	content.WriteString("}\n\n")

	content.WriteString("func (b *natsRequestReplyQueryBus) Ask(ctx context.Context, q transport.Query) (interface{}, error) {\n")
	content.WriteString("\t// Сериализуем запрос\n")
	content.WriteString("\tdata, err := b.serializer.Serialize(q)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"failed to serialize query: %w\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Формируем subject для запроса\n")
	content.WriteString("\tsubject := fmt.Sprintf(\"queries.%s\", q.QueryName())\n\n")
	content.WriteString("\t// Отправляем запрос через NATS Request-Reply\n")
	content.WriteString("\treply, err := b.adapter.Request(ctx, subject, data, b.timeout)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"request failed: %w\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Возвращаем сырые данные - десериализация будет выполнена в QueryInvoker\n")
	content.WriteString("\t// с правильным типом результата\n")
	content.WriteString("\tvar result map[string]interface{}\n")
	content.WriteString("\tif err := b.serializer.Deserialize(reply.Data, &result); err != nil {\n")
	content.WriteString("\t\t// Если не удалось десериализовать в map, возвращаем как есть\n")
	content.WriteString("\t\treturn reply.Data, nil\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\treturn result, nil\n")
	content.WriteString("}\n\n")

	content.WriteString("func (b *natsRequestReplyQueryBus) Register(handler transport.QueryHandler) error {\n")
	content.WriteString("\t// Регистрация выполняется на стороне сервера\n")
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n")

	path := "sdk/client.go"
	return g.writer.WriteFile(path, content.String())
}

// generateCommandMethod генерирует метод для команды
func (g *SDKGenerator) generateCommandMethod(cmd CommandSpec, spec *ParsedSpec) string {
	var builder strings.Builder

	methodName := cmd.Name
	cmdType := fmt.Sprintf("%sCommand", cmd.Name)

	// Находим событие для команды
	var successEvent, errorEvent string
	for _, event := range spec.Events {
		if strings.Contains(strings.ToLower(event.Name), strings.ToLower(cmd.Aggregate)) {
			if event.IsError {
				errorEvent = event.Name
			} else {
				successEvent = event.Name
			}
		}
	}
	if successEvent == "" {
		successEvent = fmt.Sprintf("%sCreatedEvent", cmd.Aggregate)
	}
	if errorEvent == "" {
		errorEvent = fmt.Sprintf("%sFailedEvent", cmd.Name)
	}

	builder.WriteString(fmt.Sprintf("// %s выполняет команду %s\n", methodName, cmd.Name))
	builder.WriteString(fmt.Sprintf("func (c *Client) %s(ctx context.Context, cmd %s) (*%s, error) {\n",
		methodName, cmdType, successEvent))
	builder.WriteString(fmt.Sprintf("\tinvoker := c.commandInvokers[%q].(invoke.CommandInvoker[%s, %s, %s])\n",
		g.converter.ToSnakeCase(cmd.Name), cmdType, successEvent, errorEvent))
	builder.WriteString("\treturn invoker.Invoke(ctx, cmd)\n")
	builder.WriteString("}\n")

	return builder.String()
}

// generateQueryMethod генерирует метод для запроса
func (g *SDKGenerator) generateQueryMethod(query QuerySpec, _ *ParsedSpec) string {
	var builder strings.Builder

	methodName := query.Name
	queryType := fmt.Sprintf("%sQuery", query.Name)
	responseType := fmt.Sprintf("%sResponse", query.Name)

	builder.WriteString(fmt.Sprintf("// %s выполняет запрос %s\n", methodName, query.Name))
	builder.WriteString(fmt.Sprintf("func (c *Client) %s(ctx context.Context, query %s) (*%s, error) {\n",
		methodName, queryType, responseType))
	builder.WriteString(fmt.Sprintf("\tinvoker := c.queryInvokers[%q].(invoke.QueryInvoker[%s, %s])\n",
		g.converter.ToSnakeCase(query.Name), queryType, responseType))
	builder.WriteString("\treturn invoker.Invoke(ctx, query)\n")
	builder.WriteString("}\n")

	return builder.String()
}

// generateSDKConfig генерирует SDK конфигурацию
func (g *SDKGenerator) generateSDKConfig(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `// Code generated by potter-gen. DO NOT EDIT.

package sdk

import "time"

// ClientConfig конфигурация SDK client
type ClientConfig struct {
	CommandTransport string
	QueryTransport  string
	NATSUrl         string
	KafkaBrokers    []string
	RESTBaseURL     string
	GRPCAddress     string
	Timeout         time.Duration
}

// DefaultConfig возвращает конфигурацию по умолчанию
func DefaultConfig() *ClientConfig {
	return &ClientConfig{
		CommandTransport: "NATS",
		QueryTransport:   "NATS",
		NATSUrl:          "nats://localhost:4222",
		KafkaBrokers:     []string{"localhost:9092"},
		RESTBaseURL:      "http://localhost:8080",
		GRPCAddress:      "localhost:50051",
		Timeout:          30 * time.Second,
	}
}
`

	path := "sdk/config.go"
	return g.writer.WriteFile(path, content)
}

// generateSDKTypes генерирует экспортируемые типы
func (g *SDKGenerator) generateSDKTypes(spec *ParsedSpec, _ *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package sdk\n\n")

	// Генерация типов команд
	for _, cmd := range spec.Commands {
		content.WriteString(fmt.Sprintf("// %sCommand команда %s\n", cmd.Name, cmd.Name))
		content.WriteString(fmt.Sprintf("type %sCommand struct {\n", cmd.Name))
		content.WriteString("\t// Add fields from request message\n")
		content.WriteString("}\n\n")
	}

	// Генерация типов запросов
	for _, query := range spec.Queries {
		content.WriteString(fmt.Sprintf("// %sQuery запрос %s\n", query.Name, query.Name))
		content.WriteString(fmt.Sprintf("type %sQuery struct {\n", query.Name))
		content.WriteString("\t// Add fields from request message\n")
		content.WriteString("}\n\n")

		content.WriteString(fmt.Sprintf("// %sResponse ответ на запрос %s\n", query.Name, query.Name))
		content.WriteString(fmt.Sprintf("type %sResponse struct {\n", query.Name))
		content.WriteString("\t// Add fields from response message\n")
		content.WriteString("}\n\n")
	}

	// Генерация типов событий
	for _, event := range spec.Events {
		content.WriteString(fmt.Sprintf("// %s событие\n", event.Name))
		content.WriteString(fmt.Sprintf("type %s struct {\n", event.Name))
		content.WriteString("\t// Add fields from event message\n")
		content.WriteString("}\n\n")
	}

	path := "sdk/types.go"
	return g.writer.WriteFile(path, content.String())
}

// generateSDKExamples генерирует примеры использования SDK
func (g *SDKGenerator) generateSDKExamples(_ *ParsedSpec, _ *GeneratorConfig) error {
	// basic_usage.go
	basicContent := `// Code generated by potter-gen. DO NOT EDIT.

package examples

import (
	"context"
	"fmt"

	"example-sdk"
)

// ExampleBasicUsage демонстрирует базовое использование SDK
func ExampleBasicUsage() {
	config := sdk.DefaultConfig()
	config.NATSUrl = "nats://localhost:4222"

	client, err := sdk.NewClient(config)
	if err != nil {
		panic(err)
	}
	defer client.Close()

	ctx := context.Background()

	// Пример выполнения команды
	event, err := client.CreateItem(ctx, sdk.CreateItemCommand{
		// Add command fields
	})
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Event: %+v\n", event)
}
`

	if err := g.writer.WriteFile("sdk/examples/basic_usage.go", basicContent); err != nil {
		return err
	}

	// with_nats.go
	natsContent := `// Code generated by potter-gen. DO NOT EDIT.

package examples

import (
	"context"
	"example-sdk"
)

// ExampleWithNATS демонстрирует использование SDK с NATS
func ExampleWithNATS() {
	config := sdk.DefaultConfig()
	config.CommandTransport = "NATS"
	config.QueryTransport = "NATS"
	config.NATSUrl = "nats://localhost:4222"

	client, _ := sdk.NewClient(config)
	defer client.Close()

	ctx := context.Background()
	_ = ctx
	// Use client methods
}
`

	if err := g.writer.WriteFile("sdk/examples/with_nats.go", natsContent); err != nil {
		return err
	}

	// with_rest.go
	restContent := `// Code generated by potter-gen. DO NOT EDIT.

package examples

import (
	"context"
	"example-sdk"
)

// ExampleWithREST демонстрирует использование SDK с REST
func ExampleWithREST() {
	config := sdk.DefaultConfig()
	config.QueryTransport = "REST"
	config.RESTBaseURL = "http://localhost:8080"

	client, _ := sdk.NewClient(config)
	defer client.Close()

	ctx := context.Background()
	_ = ctx
	// Use client methods
}
`

	return g.writer.WriteFile("sdk/examples/with_rest.go", restContent)
}

// generateSDKGoMod генерирует go.mod для SDK
func (g *SDKGenerator) generateSDKGoMod(_ *ParsedSpec, config *GeneratorConfig) error {
	sdkModulePath := config.ModulePath + "-sdk"
	content := fmt.Sprintf(`module %s

go 1.25.0

require (
	potter v0.0.0
)

replace potter => ../..
`, sdkModulePath)

	return g.writer.WriteFile("sdk/go.mod", content)
}

// generateSDKREADME генерирует README для SDK
func (g *SDKGenerator) generateSDKREADME(_ *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	sdkModulePath := config.ModulePath + "-sdk"
	content.WriteString(fmt.Sprintf("# %s\n\n", sdkModulePath))
	content.WriteString("Type-safe SDK для интеграции с сервисом.\n\n")
	content.WriteString("## Установка\n\n")
	content.WriteString(fmt.Sprintf("```bash\ngo get %s\n```\n\n", sdkModulePath))
	content.WriteString("## Использование\n\n")
	content.WriteString("```go\n")
	content.WriteString("import \"example-sdk\"\n\n")
	content.WriteString("config := sdk.DefaultConfig()\n")
	content.WriteString("config.NATSUrl = \"nats://localhost:4222\"\n")
	content.WriteString("client, _ := sdk.NewClient(config)\n")
	content.WriteString("defer client.Close()\n\n")
	content.WriteString("event, err := client.CreateItem(ctx, sdk.CreateItemCommand{\n")
	content.WriteString("\t// Add fields\n")
	content.WriteString("})\n")
	content.WriteString("```\n\n")
	content.WriteString("## Примеры\n\n")
	content.WriteString("См. `examples/` для примеров использования.\n\n")

	return g.writer.WriteFile("sdk/README.md", content.String())
}

// findSuccessEvent находит событие успеха для команды
func (g *SDKGenerator) findSuccessEvent(cmd CommandSpec, spec *ParsedSpec) string {
	// Ищем событие по агрегату и имени команды
	for _, event := range spec.Events {
		if !event.IsError {
			// Проверяем, связано ли событие с агрегатом команды
			if strings.Contains(strings.ToLower(event.Name), strings.ToLower(cmd.Aggregate)) {
				return event.Name
			}
		}
	}
	// Если не найдено, генерируем имя по паттерну
	return fmt.Sprintf("%sCreatedEvent", cmd.Aggregate)
}

// findErrorEvent находит событие ошибки для команды
func (g *SDKGenerator) findErrorEvent(cmd CommandSpec, spec *ParsedSpec) string {
	// Ищем событие ошибки
	for _, event := range spec.Events {
		if event.IsError {
			// Проверяем, связано ли событие с командой
			if strings.Contains(strings.ToLower(event.Name), strings.ToLower(cmd.Name)) {
				return event.Name
			}
		}
	}
	// Если не найдено, генерируем имя по паттерну
	return fmt.Sprintf("%sFailedEvent", cmd.Name)
}

// getEventType возвращает тип события (eventType) для использования в EventAwaiter
func (g *SDKGenerator) getEventType(eventName string, cmd CommandSpec, spec *ParsedSpec) string {
	// Ищем событие в спецификации
	for _, event := range spec.Events {
		if event.Name == eventName {
			if event.EventType != "" {
				return event.EventType
			}
			// Генерируем eventType из имени события
			return g.converter.ToSnakeCase(eventName)
		}
	}
	// Если не найдено, генерируем по паттерну
	if strings.Contains(eventName, "Created") {
		return fmt.Sprintf("%s.created", g.converter.ToSnakeCase(cmd.Aggregate))
	}
	if strings.Contains(eventName, "Failed") {
		return fmt.Sprintf("%s.failed", g.converter.ToSnakeCase(cmd.Name))
	}
	return g.converter.ToSnakeCase(eventName)
}
