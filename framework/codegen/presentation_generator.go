package codegen

import (
	"fmt"
	"strings"
)

// PresentationGenerator генератор presentation слоя
type PresentationGenerator struct {
	*BaseGenerator
}

// NewPresentationGenerator создает новый генератор presentation слоя
func NewPresentationGenerator(outputDir string) *PresentationGenerator {
	return &PresentationGenerator{
		BaseGenerator: NewBaseGenerator("presentation", outputDir),
	}
}

// Generate генерирует presentation слой
func (g *PresentationGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	// Генерация на основе указанных транспортов
	hasREST := false
	hasGraphQL := false
	hasGRPC := false

	for _, transport := range spec.Transports {
		switch transport {
		case "REST":
			hasREST = true
		case "GraphQL":
			hasGraphQL = true
		case "gRPC":
			hasGRPC = true
		}
	}

	// Если транспорты не указаны, по умолчанию генерируем REST
	if len(spec.Transports) == 0 {
		hasREST = true
	}

	// Генерация REST handler
	if hasREST {
		if err := g.generateRESTHandler(spec, config); err != nil {
			return fmt.Errorf("failed to generate REST handler: %w", err)
		}
	}

	// Генерация GraphQL интеграции
	if hasGraphQL {
		if err := g.generateGraphQLIntegration(spec, config); err != nil {
			return fmt.Errorf("failed to generate GraphQL integration: %w", err)
		}
	}

	// Генерация gRPC handler (в разработке)
	if hasGRPC {
		// TODO: реализовать generateGRPCHandler
	}

	if err := g.generateAPIExamples(spec, config); err != nil {
		return fmt.Errorf("failed to generate API examples: %w", err)
	}

	return nil
}

// generateRESTHandler генерирует REST handler
func (g *PresentationGenerator) generateRESTHandler(spec *ParsedSpec, config *GeneratorConfig) error {
	if config == nil {
		config = &GeneratorConfig{}
	}
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package rest\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"net/http\"\n")
	content.WriteString("\n")
	content.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	content.WriteString(fmt.Sprintf("\t\"%s/application/command\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/application/query\"\n", config.ModulePath))
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	content.WriteString("// Handler REST API handler\n")
	content.WriteString("type Handler struct {\n")
	content.WriteString("\tcommandBus transport.CommandBus\n")
	content.WriteString("\tqueryBus   transport.QueryBus\n")
	content.WriteString("}\n\n")

	content.WriteString("// NewHandler создает новый REST handler\n")
	content.WriteString("func NewHandler(commandBus transport.CommandBus, queryBus transport.QueryBus) *Handler {\n")
	content.WriteString("\treturn &Handler{\n")
	content.WriteString("\t\tcommandBus: commandBus,\n")
	content.WriteString("\t\tqueryBus:   queryBus,\n")
	content.WriteString("\t}\n")
	content.WriteString("}\n\n")

	content.WriteString("// RegisterRoutes регистрирует все маршруты\n")
	content.WriteString("func (h *Handler) RegisterRoutes(router *gin.Engine) {\n")
	content.WriteString("\tapi := router.Group(\"/api/v1\")\n")
	content.WriteString("\t{\n")

	// Регистрация маршрутов для команд
	for _, cmd := range spec.Commands {
		resourceName := g.converter.ToSnakeCase(cmd.Aggregate)
		cmdName := g.converter.ToSnakeCase(cmd.Name)
		content.WriteString(fmt.Sprintf("\t\tapi.POST(\"/%s/%s\", h.%s)\n", resourceName, cmdName, cmd.Name))
	}

	// Регистрация маршрутов для запросов
	for _, query := range spec.Queries {
		resourceName := g.converter.ToSnakeCase(query.Name)
		content.WriteString(fmt.Sprintf("\t\tapi.GET(\"/%s\", h.%s)\n", resourceName, query.Name))
	}

	content.WriteString("\t}\n")
	content.WriteString("}\n\n")

	// Генерация handler методов для команд
	for _, cmd := range spec.Commands {
		content.WriteString(g.generateCommandHandler(cmd))
		content.WriteString("\n")
	}

	// Генерация handler методов для запросов
	for _, query := range spec.Queries {
		content.WriteString(g.generateQueryHandler(query))
		content.WriteString("\n")
	}

	path := "presentation/rest/handler.go"
	return g.writer.WriteFile(path, content.String())
}

// generateCommandHandler генерирует handler метод для команды
func (g *PresentationGenerator) generateCommandHandler(cmd CommandSpec) string {
	var builder strings.Builder

	builder.WriteString(fmt.Sprintf("// %s обрабатывает команду %s\n",
		strings.ToLower(cmd.Name), cmd.Name))
	builder.WriteString(fmt.Sprintf("func (h *Handler) %s(c *gin.Context) {\n", cmd.Name))
	builder.WriteString("\tvar req struct {\n")
	builder.WriteString("\t\t// Add request fields from command\n")
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tif err := c.ShouldBindJSON(&req); err != nil {\n")
	builder.WriteString("\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n")
	builder.WriteString("\t\treturn\n")
	builder.WriteString("\t}\n\n")
	builder.WriteString(fmt.Sprintf("\tcmd := command.%sCommand{\n", cmd.Name))
	builder.WriteString("\t\t// Map request fields to command\n")
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tif err := h.commandBus.Send(c.Request.Context(), cmd); err != nil {\n")
	builder.WriteString("\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n")
	builder.WriteString("\t\treturn\n")
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tc.JSON(http.StatusCreated, gin.H{\"message\": \"Command executed successfully\"})\n")
	builder.WriteString("}\n")

	return builder.String()
}

// generateQueryHandler генерирует handler метод для запроса
func (g *PresentationGenerator) generateQueryHandler(query QuerySpec) string {
	var builder strings.Builder

	builder.WriteString(fmt.Sprintf("// %s обрабатывает запрос %s\n",
		strings.ToLower(query.Name), query.Name))
	builder.WriteString(fmt.Sprintf("func (h *Handler) %s(c *gin.Context) {\n", query.Name))
	builder.WriteString(fmt.Sprintf("\tq := query.%sQuery{\n", query.Name))
	builder.WriteString("\t\t// Map query parameters to query\n")
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tresult, err := h.queryBus.Ask(c.Request.Context(), q)\n")
	builder.WriteString("\tif err != nil {\n")
	builder.WriteString("\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": err.Error()})\n")
	builder.WriteString("\t\treturn\n")
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tc.JSON(http.StatusOK, result)\n")
	builder.WriteString("}\n")

	return builder.String()
}

// generateAPIExamples генерирует примеры API
func (g *PresentationGenerator) generateAPIExamples(spec *ParsedSpec, _ *GeneratorConfig) error {
	// Генерация api_examples.md
	var mdContent strings.Builder
	mdContent.WriteString("# API Examples\n\n")
	mdContent.WriteString("Примеры использования API.\n\n")

	// Примеры для команд
	mdContent.WriteString("## Commands\n\n")
	for _, cmd := range spec.Commands {
		resourceName := g.converter.ToSnakeCase(cmd.Aggregate)
		cmdName := g.converter.ToSnakeCase(cmd.Name)
		mdContent.WriteString(fmt.Sprintf("### %s\n\n", cmd.Name))
		mdContent.WriteString("```bash\n")
		mdContent.WriteString(fmt.Sprintf("curl -X POST http://localhost:8080/api/v1/%s/%s \\\n",
			resourceName, cmdName))
		mdContent.WriteString("\t-H \"Content-Type: application/json\" \\\n")
		mdContent.WriteString("\t-d '{\n")
		mdContent.WriteString("\t\t\"field\": \"value\"\n")
		mdContent.WriteString("\t}'\n")
		mdContent.WriteString("```\n\n")
	}

	// Примеры для запросов
	mdContent.WriteString("## Queries\n\n")
	for _, query := range spec.Queries {
		resourceName := g.converter.ToSnakeCase(query.Name)
		mdContent.WriteString(fmt.Sprintf("### %s\n\n", query.Name))
		mdContent.WriteString("```bash\n")
		mdContent.WriteString(fmt.Sprintf("curl http://localhost:8080/api/v1/%s\n", resourceName))
		mdContent.WriteString("```\n\n")
	}

	// Добавление GraphQL примеров, если GraphQL включен
	hasGraphQL := false
	for _, transport := range spec.Transports {
		if transport == "GraphQL" {
			hasGraphQL = true
			break
		}
	}

	if hasGraphQL {
		mdContent.WriteString("## GraphQL\n\n")
		mdContent.WriteString("GraphQL endpoint доступен на `http://localhost:8082/graphql`\n\n")
		mdContent.WriteString("### GraphQL Playground\n\n")
		mdContent.WriteString("Для интерактивного тестирования используйте GraphQL Playground:\n\n")
		mdContent.WriteString("```bash\n")
		mdContent.WriteString("open http://localhost:8082/graphql\n")
		mdContent.WriteString("```\n\n")

		mdContent.WriteString("### GraphQL Queries\n\n")
		for _, query := range spec.Queries {
			fieldName := g.toCamelCase(query.Name)
			mdContent.WriteString(fmt.Sprintf("#### %s\n\n", query.Name))
			mdContent.WriteString("```graphql\n")
			mdContent.WriteString(fmt.Sprintf("query {\n  %s(id: \"1\") {\n    id\n  }\n}\n", fieldName))
			mdContent.WriteString("```\n\n")
		}

		mdContent.WriteString("### GraphQL Mutations\n\n")
		for _, cmd := range spec.Commands {
			fieldName := g.toCamelCase(cmd.Name)
			mdContent.WriteString(fmt.Sprintf("#### %s\n\n", cmd.Name))
			mdContent.WriteString("```graphql\n")
			mdContent.WriteString(fmt.Sprintf("mutation {\n  %s(input: {}) {\n    id\n  }\n}\n", fieldName))
			mdContent.WriteString("```\n\n")
		}

		mdContent.WriteString("### GraphQL Subscriptions\n\n")
		for _, event := range spec.Events {
			if !event.IsError {
				fieldName := g.toCamelCase(event.Name)
				mdContent.WriteString(fmt.Sprintf("#### %s\n\n", event.Name))
				mdContent.WriteString("```graphql\n")
				mdContent.WriteString(fmt.Sprintf("subscription {\n  %s {\n    id\n  }\n}\n", fieldName))
				mdContent.WriteString("```\n\n")
			}
		}
	}

	if err := g.writer.WriteFile("api_examples.md", mdContent.String()); err != nil {
		return err
	}

	// Генерация api_examples.http
	var httpContent strings.Builder
	httpContent.WriteString("### API Examples\n\n")
	httpContent.WriteString("### Commands\n\n")
	for _, cmd := range spec.Commands {
		resourceName := g.converter.ToSnakeCase(cmd.Aggregate)
		cmdName := g.converter.ToSnakeCase(cmd.Name)
		httpContent.WriteString(fmt.Sprintf("POST http://localhost:8080/api/v1/%s/%s\n",
			resourceName, cmdName))
		httpContent.WriteString("Content-Type: application/json\n\n")
		httpContent.WriteString("{\n")
		httpContent.WriteString("\t\"field\": \"value\"\n")
		httpContent.WriteString("}\n\n")
	}

	httpContent.WriteString("### Queries\n\n")
	for _, query := range spec.Queries {
		resourceName := g.converter.ToSnakeCase(query.Name)
		httpContent.WriteString(fmt.Sprintf("GET http://localhost:8080/api/v1/%s\n\n", resourceName))
	}

	if hasGraphQL {
		httpContent.WriteString("### GraphQL Queries\n\n")
		for _, query := range spec.Queries {
			fieldName := g.toCamelCase(query.Name)
			httpContent.WriteString(fmt.Sprintf("POST http://localhost:8082/graphql\n"))
			httpContent.WriteString("Content-Type: application/json\n\n")
			httpContent.WriteString("{\n")
			httpContent.WriteString(fmt.Sprintf("  \"query\": \"query { %s(id: \\\"1\\\") { id } }\"\n", fieldName))
			httpContent.WriteString("}\n\n")
		}

		httpContent.WriteString("### GraphQL Mutations\n\n")
		for _, cmd := range spec.Commands {
			fieldName := g.toCamelCase(cmd.Name)
			httpContent.WriteString(fmt.Sprintf("POST http://localhost:8082/graphql\n"))
			httpContent.WriteString("Content-Type: application/json\n\n")
			httpContent.WriteString("{\n")
			httpContent.WriteString(fmt.Sprintf("  \"query\": \"mutation { %s(input: {}) { id } }\"\n", fieldName))
			httpContent.WriteString("}\n\n")
		}

		httpContent.WriteString("### GraphQL Subscriptions\n\n")
		for _, event := range spec.Events {
			if !event.IsError {
				fieldName := g.toCamelCase(event.Name)
				httpContent.WriteString(fmt.Sprintf("WebSocket: ws://localhost:8082/graphql\n"))
				httpContent.WriteString(fmt.Sprintf("Subscription: subscription { %s { id } }\n\n", fieldName))
			}
		}
	}

	return g.writer.WriteFile("api_examples.http", httpContent.String())
}

// toCamelCase конвертирует имя в camelCase
func (g *PresentationGenerator) toCamelCase(s string) string {
	if len(s) == 0 {
		return s
	}
	// Простая конвертация: первая буква в нижний регистр
	return strings.ToLower(s[:1]) + s[1:]
}

// generateGraphQLIntegration генерирует GraphQL адаптер и схему
func (g *PresentationGenerator) generateGraphQLIntegration(spec *ParsedSpec, config *GeneratorConfig) error {
	// Генерация GraphQL схемы через GraphQLSchemaGenerator
	graphqlGen := NewGraphQLSchemaGenerator(g.outputDir)
	if err := graphqlGen.Generate(spec, config); err != nil {
		return fmt.Errorf("failed to generate GraphQL schema: %w", err)
	}

	// Генерация GraphQL адаптера
	if err := g.generateGraphQLAdapter(spec, config); err != nil {
		return fmt.Errorf("failed to generate GraphQL adapter: %w", err)
	}

	return nil
}

// generateGraphQLAdapter генерирует GraphQL адаптер для интеграции с CQRS
func (g *PresentationGenerator) generateGraphQLAdapter(spec *ParsedSpec, config *GeneratorConfig) error {
	if config == nil {
		config = &GeneratorConfig{}
	}
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package graphql\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"log\"\n")
	content.WriteString("\n")
	content.WriteString("\t\"github.com/99designs/gqlgen/graphql\"\n")
	content.WriteString(fmt.Sprintf("\t\"%s/application/command\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/application/query\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/config\"\n", config.ModulePath))
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/events\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	content.WriteString("// NewGraphQLAdapter создает и настраивает GraphQL адаптер с интеграцией CQRS\n")
	content.WriteString("func NewGraphQLAdapter(\n")
	content.WriteString("\tcfg *config.Config,\n")
	content.WriteString("\tcommandBus transport.CommandBus,\n")
	content.WriteString("\tqueryBus transport.QueryBus,\n")
	content.WriteString("\teventBus events.EventBus,\n")
	content.WriteString("\texecutableSchema graphql.ExecutableSchema,\n")
	content.WriteString(") (*transport.GraphQLAdapter, error) {\n")
	content.WriteString("\tgraphQLConfig := transport.DefaultGraphQLConfig()\n")
	content.WriteString("\tgraphQLConfig.Port = cfg.GraphQL.Port\n")
	content.WriteString("\tgraphQLConfig.EnablePlayground = cfg.GraphQL.EnablePlayground\n")
	content.WriteString("\tgraphQLConfig.EnableIntrospection = cfg.GraphQL.EnableIntrospection\n")
	content.WriteString("\tgraphQLConfig.ComplexityLimit = cfg.GraphQL.ComplexityLimit\n")
	content.WriteString("\tgraphQLConfig.MaxDepth = cfg.GraphQL.MaxDepth\n\n")
	content.WriteString("\tadapter, err := transport.NewGraphQLAdapterWithCQRS(\n")
	content.WriteString("\t\tgraphQLConfig,\n")
	content.WriteString("\t\tcommandBus,\n")
	content.WriteString("\t\tqueryBus,\n")
	content.WriteString("\t\teventBus,\n")
	content.WriteString("\t\texecutableSchema,\n")
	content.WriteString("\t)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"failed to create GraphQL adapter: %w\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Автоматическая регистрация резолверов\n")
	content.WriteString("\tif err := adapter.AutoRegisterResolvers(); err != nil {\n")
	content.WriteString("\t\tlog.Printf(\"Warning: failed to auto-register resolvers: %v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\treturn adapter, nil\n")
	content.WriteString("}\n")

	path := "presentation/graphql/adapter.go"
	return g.writer.WriteFile(path, content.String())
}
