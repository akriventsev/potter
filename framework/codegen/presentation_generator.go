package codegen

import (
	"fmt"
	"strings"
)

// PresentationGenerator генератор presentation слоя
type PresentationGenerator struct {
	*BaseGenerator
}

// NewPresentationGenerator создает новый генератор presentation слоя
func NewPresentationGenerator(outputDir string) *PresentationGenerator {
	return &PresentationGenerator{
		BaseGenerator: NewBaseGenerator("presentation", outputDir),
	}
}

// Generate генерирует presentation слой
func (g *PresentationGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	// Генерация на основе указанных транспортов
	hasREST := false
	hasGraphQL := false
	hasGRPC := false

	for _, transport := range spec.Transports {
		switch transport {
		case "REST":
			hasREST = true
		case "GraphQL":
			hasGraphQL = true
		case "gRPC":
			hasGRPC = true
		}
	}

	// Если транспорты не указаны, по умолчанию генерируем REST
	if len(spec.Transports) == 0 {
		hasREST = true
	}

	// Генерация REST handler
	if hasREST {
		if err := g.generateRESTHandler(spec, config); err != nil {
			return fmt.Errorf("failed to generate REST handler: %w", err)
		}
	}

	// Генерация GraphQL интеграции
	if hasGraphQL {
		if err := g.generateGraphQLIntegration(spec, config); err != nil {
			return fmt.Errorf("failed to generate GraphQL integration: %w", err)
		}
	}

	// Генерация gRPC handler (в разработке)
	if hasGRPC {
		// TODO: реализовать generateGRPCHandler
	}

	if err := g.generateAPIExamples(spec, config); err != nil {
		return fmt.Errorf("failed to generate API examples: %w", err)
	}

	return nil
}

// generateRESTHandler генерирует REST handler
func (g *PresentationGenerator) generateRESTHandler(spec *ParsedSpec, config *GeneratorConfig) error {
	if config == nil {
		config = &GeneratorConfig{}
	}
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package rest\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	content.WriteString("// Handler REST API handler\n")
	content.WriteString("type Handler struct {\n")
	content.WriteString("\tcommandBus transport.CommandBus\n")
	content.WriteString("\tqueryBus   transport.QueryBus\n")
	content.WriteString("}\n\n")

	content.WriteString("// NewHandler создает новый REST handler\n")
	content.WriteString("func NewHandler(commandBus transport.CommandBus, queryBus transport.QueryBus) *Handler {\n")
	content.WriteString("\treturn &Handler{\n")
	content.WriteString("\t\tcommandBus: commandBus,\n")
	content.WriteString("\t\tqueryBus:   queryBus,\n")
	content.WriteString("\t}\n")
	content.WriteString("}\n\n")

	content.WriteString("// RegisterRoutes регистрирует все маршруты в соответствии с REST концепцией\n")
	content.WriteString("func (h *Handler) RegisterRoutes(router *gin.Engine) {\n")
	content.WriteString("\tapi := router.Group(\"/api/v1\")\n")
	content.WriteString("\t{\n")

	// Группируем команды и запросы по ресурсам (агрегатам)
	resourceRoutes := make(map[string][]CommandSpec)
	resourceQueries := make(map[string][]QuerySpec)

	// Группируем команды по агрегатам
	for _, cmd := range spec.Commands {
		resourceName := g.converter.ToSnakeCase(cmd.Aggregate)
		// Делаем множественное число для REST ресурсов
		if !strings.HasSuffix(resourceName, "s") {
			resourceName = resourceName + "s"
		}
		resourceRoutes[resourceName] = append(resourceRoutes[resourceName], cmd)
	}

	// Группируем запросы по агрегатам (определяем по имени запроса или по связанному агрегату)
	for _, query := range spec.Queries {
		// Сначала пытаемся определить ресурс из имени запроса
		resourceName := g.inferResourceFromQuery(query.Name)
		// Нормализуем к множественному числу для REST
		if !strings.HasSuffix(resourceName, "s") {
			resourceName = resourceName + "s"
		}
		resourceQueries[resourceName] = append(resourceQueries[resourceName], query)
	}

	// Регистрируем маршруты для каждого ресурса
	allResources := make(map[string]bool)
	for resource := range resourceRoutes {
		allResources[resource] = true
	}
	for resource := range resourceQueries {
		allResources[resource] = true
	}

	for resource := range allResources {
		// Регистрация маршрутов для команд
		for _, cmd := range resourceRoutes[resource] {
			httpMethod, route := g.getRESTRouteForCommand(cmd, resource)
			content.WriteString(fmt.Sprintf("\t\tapi.%s(\"%s\", h.%s)\n", httpMethod, route, cmd.Name))
		}

		// Регистрация маршрутов для запросов
		for _, query := range resourceQueries[resource] {
			route := g.getRESTRouteForQuery(query, resource)
			content.WriteString(fmt.Sprintf("\t\tapi.GET(\"%s\", h.%s)\n", route, query.Name))
		}
	}

	content.WriteString("\t}\n")
	content.WriteString("\t// Дополнительные маршруты можно зарегистрировать в пользовательском файле handler.go\n")
	content.WriteString("}\n")

	path := "presentation/rest/handler.gen.go"
	if err := g.writer.WriteFile(path, content.String()); err != nil {
		return err
	}

	// Генерация пользовательского файла с обработчиками
	return g.generateRESTHandlerUserCode(spec, config)
}

// generateRESTHandlerUserCode генерирует пользовательский файл с обработчиками REST API
func (g *PresentationGenerator) generateRESTHandlerUserCode(spec *ParsedSpec, config *GeneratorConfig) error {
	var userContent strings.Builder

	userContent.WriteString("package rest\n\n")
	userContent.WriteString("// Этот файл содержит пользовательские обработчики REST API.\n")
	userContent.WriteString("// Вы можете свободно редактировать этот файл - он не будет перезаписан при регенерации.\n")
	userContent.WriteString("// Здесь вы можете кастомизировать обработку запросов, добавить валидацию, логирование и т.д.\n\n")
	// Проверяем, нужен ли импорт strconv для парсинга числовых значений
	needsStrconv := false
	for _, query := range spec.Queries {
		for _, field := range query.RequestFields {
			goType := g.protoToGoType(field.Type, field.Repeated)
			if goType == "int32" || goType == "int64" {
				needsStrconv = true
				break
			}
		}
		if needsStrconv {
			break
		}
	}
	
	userContent.WriteString("import (\n")
	userContent.WriteString("\t\"net/http\"\n")
	if needsStrconv {
		userContent.WriteString("\t\"strconv\"\n")
	}
	userContent.WriteString("\n")
	userContent.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	userContent.WriteString(fmt.Sprintf("\t\"%s/application/command\"\n", config.ModulePath))
	userContent.WriteString(fmt.Sprintf("\t\"%s/application/query\"\n", config.ModulePath))
	userContent.WriteString(")\n\n")

	// Генерация handler методов для команд
	for _, cmd := range spec.Commands {
		userContent.WriteString(g.generateCommandHandler(cmd))
		userContent.WriteString("\n")
	}

	// Генерация handler методов для запросов
	for _, query := range spec.Queries {
		userContent.WriteString(g.generateQueryHandler(query))
		userContent.WriteString("\n")
	}

	userPath := "presentation/rest/handler.go"
	return g.writer.WriteFile(userPath, userContent.String())
}

// generateCommandHandler генерирует handler метод для команды
func (g *PresentationGenerator) generateCommandHandler(cmd CommandSpec) string {
	var builder strings.Builder

	cmdNameLower := strings.ToLower(cmd.Name)
	needsID := strings.HasPrefix(cmdNameLower, "update") || strings.HasPrefix(cmdNameLower, "delete")
	isCreate := strings.HasPrefix(cmdNameLower, "create")
	isDelete := strings.HasPrefix(cmdNameLower, "delete")

	builder.WriteString(fmt.Sprintf("// %s обрабатывает команду %s\n",
		strings.ToLower(cmd.Name), cmd.Name))
	builder.WriteString(fmt.Sprintf("func (h *Handler) %s(c *gin.Context) {\n", cmd.Name))
	
	// Для Update и Delete команд извлекаем ID из URL параметра
	if needsID {
		builder.WriteString("\t// Извлечение ID из URL параметра\n")
		builder.WriteString("\tid := c.Param(\"id\")\n")
		builder.WriteString("\tif id == \"\" {\n")
		builder.WriteString("\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"id parameter is required\"})\n")
		builder.WriteString("\t\treturn\n")
		builder.WriteString("\t}\n\n")
	}

	// Для Delete команды не нужен JSON body
	if !isDelete {
		builder.WriteString(fmt.Sprintf("\tvar req command.%sCommand\n", cmd.Name))
		builder.WriteString("\tif err := c.ShouldBindJSON(&req); err != nil {\n")
		builder.WriteString("\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n")
		builder.WriteString("\t\treturn\n")
		builder.WriteString("\t}\n\n")
	}

	builder.WriteString(fmt.Sprintf("\tcmd := command.%sCommand{\n", cmd.Name))
	if needsID {
		// Находим поле ID в RequestFields и устанавливаем его из URL параметра
		hasIDField := false
		for _, field := range cmd.RequestFields {
			if strings.ToLower(field.Name) == "id" {
				hasIDField = true
				fieldName := g.toPublicField(field.Name)
				builder.WriteString(fmt.Sprintf("\t\t%s: id,\n", fieldName))
				break
			}
		}
		if !hasIDField {
			builder.WriteString("\t\t// TODO: Set ID field from URL parameter\n")
			builder.WriteString("\t\t// ID: id,\n")
		}
	}
	if !isDelete {
		// Маппим поля из req в cmd
		for _, field := range cmd.RequestFields {
			fieldName := g.toPublicField(field.Name)
			// Пропускаем ID для Update/Delete команд, так как он уже установлен из URL
			if needsID && strings.ToLower(field.Name) == "id" {
				continue
			}
			builder.WriteString(fmt.Sprintf("\t\t%s: req.%s,\n", fieldName, fieldName))
		}
	}
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tif err := h.commandBus.Send(c.Request.Context(), cmd); err != nil {\n")
	builder.WriteString("\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n")
	builder.WriteString("\t\treturn\n")
	builder.WriteString("\t}\n\n")

	// Разные статус коды для разных операций
	if isCreate {
		builder.WriteString("\tc.JSON(http.StatusCreated, gin.H{\"message\": \"Resource created successfully\"})\n")
	} else if isDelete {
		builder.WriteString("\tc.JSON(http.StatusOK, gin.H{\"message\": \"Resource deleted successfully\"})\n")
	} else {
		builder.WriteString("\tc.JSON(http.StatusOK, gin.H{\"message\": \"Resource updated successfully\"})\n")
	}
	builder.WriteString("}\n")

	return builder.String()
}

// generateQueryHandler генерирует handler метод для запроса
func (g *PresentationGenerator) generateQueryHandler(query QuerySpec) string {
	var builder strings.Builder

	queryNameLower := strings.ToLower(query.Name)
	isGet := strings.HasPrefix(queryNameLower, "get")
	isList := strings.HasPrefix(queryNameLower, "list")

	builder.WriteString(fmt.Sprintf("// %s обрабатывает запрос %s\n",
		strings.ToLower(query.Name), query.Name))
	builder.WriteString(fmt.Sprintf("func (h *Handler) %s(c *gin.Context) {\n", query.Name))
	
	// Для Get запросов извлекаем ID из URL параметра
	if isGet {
		builder.WriteString("\t// Извлечение ID из URL параметра\n")
		builder.WriteString("\tid := c.Param(\"id\")\n")
		builder.WriteString("\tif id == \"\" {\n")
		builder.WriteString("\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"id parameter is required\"})\n")
		builder.WriteString("\t\treturn\n")
		builder.WriteString("\t}\n\n")
	}

	builder.WriteString(fmt.Sprintf("\tq := query.%sQuery{\n", query.Name))
	if isGet {
		// Находим поле ID в RequestFields и устанавливаем его из URL параметра
		hasIDField := false
		for _, field := range query.RequestFields {
			if strings.ToLower(field.Name) == "id" {
				hasIDField = true
				fieldName := g.toPublicField(field.Name)
				builder.WriteString(fmt.Sprintf("\t\t%s: id,\n", fieldName))
				break
			}
		}
		if !hasIDField {
			builder.WriteString("\t\t// TODO: Set ID field from URL parameter\n")
			builder.WriteString("\t\t// ID: id,\n")
		}
	} else if isList {
		// Маппим query параметры из URL
		for _, field := range query.RequestFields {
			fieldName := g.toPublicField(field.Name)
			fieldSnake := g.converter.ToSnakeCase(field.Name)
			goType := g.protoToGoType(field.Type, field.Repeated)
			if goType == "int32" || goType == "int64" {
				builder.WriteString(fmt.Sprintf("\t\t%s: func() %s {\n", fieldName, goType))
				builder.WriteString(fmt.Sprintf("\t\t\tval := c.DefaultQuery(\"%s\", \"0\")\n", fieldSnake))
				builder.WriteString(fmt.Sprintf("\t\t\tif parsed, err := strconv.ParseInt(val, 10, 32); err == nil {\n"))
				if goType == "int32" {
					builder.WriteString("\t\t\t\treturn int32(parsed)\n")
				} else {
					builder.WriteString("\t\t\t\treturn parsed\n")
				}
				builder.WriteString("\t\t\t}\n")
				builder.WriteString("\t\t\treturn 0\n")
				builder.WriteString("\t\t}(),\n")
			} else {
				builder.WriteString(fmt.Sprintf("\t\t%s: c.DefaultQuery(\"%s\", \"\"),\n", fieldName, fieldSnake))
			}
		}
	} else {
		// Маппим query параметры из URL для других типов запросов
		for _, field := range query.RequestFields {
			fieldName := g.toPublicField(field.Name)
			fieldSnake := g.converter.ToSnakeCase(field.Name)
			goType := g.protoToGoType(field.Type, field.Repeated)
			if goType == "int32" || goType == "int64" {
				builder.WriteString(fmt.Sprintf("\t\t%s: func() %s {\n", fieldName, goType))
				builder.WriteString(fmt.Sprintf("\t\t\tval := c.Query(\"%s\")\n", fieldSnake))
				builder.WriteString(fmt.Sprintf("\t\t\tif parsed, err := strconv.ParseInt(val, 10, 32); err == nil {\n"))
				if goType == "int32" {
					builder.WriteString("\t\t\t\treturn int32(parsed)\n")
				} else {
					builder.WriteString("\t\t\t\treturn parsed\n")
				}
				builder.WriteString("\t\t\t}\n")
				builder.WriteString("\t\t\treturn 0\n")
				builder.WriteString("\t\t}(),\n")
			} else {
				builder.WriteString(fmt.Sprintf("\t\t%s: c.Query(\"%s\"),\n", fieldName, fieldSnake))
			}
		}
	}
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tresult, err := h.queryBus.Ask(c.Request.Context(), q)\n")
	builder.WriteString("\tif err != nil {\n")
	builder.WriteString("\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": err.Error()})\n")
	builder.WriteString("\t\treturn\n")
	builder.WriteString("\t}\n\n")
	builder.WriteString("\tc.JSON(http.StatusOK, result)\n")
	builder.WriteString("}\n")

	return builder.String()
}

// generateAPIExamples генерирует примеры API
func (g *PresentationGenerator) generateAPIExamples(spec *ParsedSpec, _ *GeneratorConfig) error {
	// Генерация api_examples.md
	var mdContent strings.Builder
	mdContent.WriteString("# API Examples\n\n")
	mdContent.WriteString("Примеры использования API.\n\n")

	// Примеры для команд
	mdContent.WriteString("## Commands\n\n")
	for _, cmd := range spec.Commands {
		resourceName := g.converter.ToSnakeCase(cmd.Aggregate)
		cmdName := g.converter.ToSnakeCase(cmd.Name)
		mdContent.WriteString(fmt.Sprintf("### %s\n\n", cmd.Name))
		mdContent.WriteString("```bash\n")
		mdContent.WriteString(fmt.Sprintf("curl -X POST http://localhost:8080/api/v1/%s/%s \\\n",
			resourceName, cmdName))
		mdContent.WriteString("\t-H \"Content-Type: application/json\" \\\n")
		mdContent.WriteString("\t-d '{\n")
		mdContent.WriteString("\t\t\"field\": \"value\"\n")
		mdContent.WriteString("\t}'\n")
		mdContent.WriteString("```\n\n")
	}

	// Примеры для запросов
	mdContent.WriteString("## Queries\n\n")
	for _, query := range spec.Queries {
		resourceName := g.converter.ToSnakeCase(query.Name)
		mdContent.WriteString(fmt.Sprintf("### %s\n\n", query.Name))
		mdContent.WriteString("```bash\n")
		mdContent.WriteString(fmt.Sprintf("curl http://localhost:8080/api/v1/%s\n", resourceName))
		mdContent.WriteString("```\n\n")
	}

	// Добавление GraphQL примеров, если GraphQL включен
	hasGraphQL := false
	for _, transport := range spec.Transports {
		if transport == "GraphQL" {
			hasGraphQL = true
			break
		}
	}

	if hasGraphQL {
		mdContent.WriteString("## GraphQL\n\n")
		mdContent.WriteString("GraphQL endpoint доступен на `http://localhost:8082/graphql`\n\n")
		mdContent.WriteString("### GraphQL Playground\n\n")
		mdContent.WriteString("Для интерактивного тестирования используйте GraphQL Playground:\n\n")
		mdContent.WriteString("```bash\n")
		mdContent.WriteString("open http://localhost:8082/graphql\n")
		mdContent.WriteString("```\n\n")

		mdContent.WriteString("### GraphQL Queries\n\n")
		for _, query := range spec.Queries {
			fieldName := g.toCamelCase(query.Name)
			mdContent.WriteString(fmt.Sprintf("#### %s\n\n", query.Name))
			mdContent.WriteString("```graphql\n")
			mdContent.WriteString(fmt.Sprintf("query {\n  %s(id: \"1\") {\n    id\n  }\n}\n", fieldName))
			mdContent.WriteString("```\n\n")
		}

		mdContent.WriteString("### GraphQL Mutations\n\n")
		for _, cmd := range spec.Commands {
			fieldName := g.toCamelCase(cmd.Name)
			mdContent.WriteString(fmt.Sprintf("#### %s\n\n", cmd.Name))
			mdContent.WriteString("```graphql\n")
			mdContent.WriteString(fmt.Sprintf("mutation {\n  %s(input: {}) {\n    id\n  }\n}\n", fieldName))
			mdContent.WriteString("```\n\n")
		}

		mdContent.WriteString("### GraphQL Subscriptions\n\n")
		for _, event := range spec.Events {
			if !event.IsError {
				fieldName := g.toCamelCase(event.Name)
				mdContent.WriteString(fmt.Sprintf("#### %s\n\n", event.Name))
				mdContent.WriteString("```graphql\n")
				mdContent.WriteString(fmt.Sprintf("subscription {\n  %s {\n    id\n  }\n}\n", fieldName))
				mdContent.WriteString("```\n\n")
			}
		}
	}

	if err := g.writer.WriteFile("api_examples.md", mdContent.String()); err != nil {
		return err
	}

	// Генерация api_examples.http
	var httpContent strings.Builder
	httpContent.WriteString("### API Examples\n\n")
	httpContent.WriteString("### Commands\n\n")
	for _, cmd := range spec.Commands {
		resourceName := g.converter.ToSnakeCase(cmd.Aggregate)
		cmdName := g.converter.ToSnakeCase(cmd.Name)
		httpContent.WriteString(fmt.Sprintf("POST http://localhost:8080/api/v1/%s/%s\n",
			resourceName, cmdName))
		httpContent.WriteString("Content-Type: application/json\n\n")
		httpContent.WriteString("{\n")
		httpContent.WriteString("\t\"field\": \"value\"\n")
		httpContent.WriteString("}\n\n")
	}

	httpContent.WriteString("### Queries\n\n")
	for _, query := range spec.Queries {
		resourceName := g.converter.ToSnakeCase(query.Name)
		httpContent.WriteString(fmt.Sprintf("GET http://localhost:8080/api/v1/%s\n\n", resourceName))
	}

	if hasGraphQL {
		httpContent.WriteString("### GraphQL Queries\n\n")
		for _, query := range spec.Queries {
			fieldName := g.toCamelCase(query.Name)
			httpContent.WriteString(fmt.Sprintf("POST http://localhost:8082/graphql\n"))
			httpContent.WriteString("Content-Type: application/json\n\n")
			httpContent.WriteString("{\n")
			httpContent.WriteString(fmt.Sprintf("  \"query\": \"query { %s(id: \\\"1\\\") { id } }\"\n", fieldName))
			httpContent.WriteString("}\n\n")
		}

		httpContent.WriteString("### GraphQL Mutations\n\n")
		for _, cmd := range spec.Commands {
			fieldName := g.toCamelCase(cmd.Name)
			httpContent.WriteString(fmt.Sprintf("POST http://localhost:8082/graphql\n"))
			httpContent.WriteString("Content-Type: application/json\n\n")
			httpContent.WriteString("{\n")
			httpContent.WriteString(fmt.Sprintf("  \"query\": \"mutation { %s(input: {}) { id } }\"\n", fieldName))
			httpContent.WriteString("}\n\n")
		}

		httpContent.WriteString("### GraphQL Subscriptions\n\n")
		for _, event := range spec.Events {
			if !event.IsError {
				fieldName := g.toCamelCase(event.Name)
				httpContent.WriteString(fmt.Sprintf("WebSocket: ws://localhost:8082/graphql\n"))
				httpContent.WriteString(fmt.Sprintf("Subscription: subscription { %s { id } }\n\n", fieldName))
			}
		}
	}

	return g.writer.WriteFile("api_examples.http", httpContent.String())
}

// toCamelCase конвертирует имя в camelCase
func (g *PresentationGenerator) toCamelCase(s string) string {
	if len(s) == 0 {
		return s
	}
	// Простая конвертация: первая буква в нижний регистр
	return strings.ToLower(s[:1]) + s[1:]
}

// getRESTRouteForCommand определяет HTTP метод и маршрут для команды в соответствии с REST
func (g *PresentationGenerator) getRESTRouteForCommand(cmd CommandSpec, resourceName string) (string, string) {
	cmdName := strings.ToLower(cmd.Name)
	
	// Определяем тип команды по имени
	if strings.HasPrefix(cmdName, "create") {
		// POST /api/v1/{resource} - создание ресурса
		return "POST", fmt.Sprintf("/%s", resourceName)
	} else if strings.HasPrefix(cmdName, "update") {
		// PUT /api/v1/{resource}/:id - обновление ресурса
		return "PUT", fmt.Sprintf("/%s/:id", resourceName)
	} else if strings.HasPrefix(cmdName, "delete") {
		// DELETE /api/v1/{resource}/:id - удаление ресурса
		return "DELETE", fmt.Sprintf("/%s/:id", resourceName)
	}
	
	// По умолчанию POST для других команд
	return "POST", fmt.Sprintf("/%s/%s", resourceName, g.converter.ToSnakeCase(cmd.Name))
}

// getRESTRouteForQuery определяет маршрут для запроса в соответствии с REST
func (g *PresentationGenerator) getRESTRouteForQuery(query QuerySpec, resourceName string) string {
	queryName := strings.ToLower(query.Name)
	
	// Определяем тип запроса по имени
	if strings.HasPrefix(queryName, "get") {
		// GET /api/v1/{resource}/:id - получение одного ресурса
		return fmt.Sprintf("/%s/:id", resourceName)
	} else if strings.HasPrefix(queryName, "list") {
		// GET /api/v1/{resource} - получение списка ресурсов
		return fmt.Sprintf("/%s", resourceName)
	}
	
	// По умолчанию GET /api/v1/{resource}/{query_name}
	return fmt.Sprintf("/%s/%s", resourceName, g.converter.ToSnakeCase(query.Name))
}

// inferResourceFromQuery определяет имя ресурса из имени запроса
func (g *PresentationGenerator) inferResourceFromQuery(queryName string) string {
	queryNameLower := strings.ToLower(queryName)
	
	// Убираем префиксы Get, List, Find, Search и т.д.
	prefixes := []string{"get", "list", "find", "search", "fetch", "retrieve", "query"}
	for _, prefix := range prefixes {
		if strings.HasPrefix(queryNameLower, prefix) {
			resource := strings.TrimPrefix(queryNameLower, prefix)
			// Если осталось пусто или только одна буква, используем множественное число
			if len(resource) <= 1 {
				// Пытаемся определить из полного имени
				resource = queryNameLower
			}
			// Конвертируем в snake_case
			resourceSnake := g.converter.ToSnakeCase(resource)
			// Возвращаем в единственном числе (будет преобразовано в множественное при регистрации маршрутов)
			// GetItem -> item, ListItems -> items -> item
			// Убираем 's' в конце если есть
			if strings.HasSuffix(resourceSnake, "s") && len(resourceSnake) > 1 {
				return strings.TrimSuffix(resourceSnake, "s")
			}
			return resourceSnake
		}
	}
	
	// По умолчанию используем имя запроса в snake_case
	resourceSnake := g.converter.ToSnakeCase(queryName)
	// Убираем 's' в конце если есть
	if strings.HasSuffix(resourceSnake, "s") && len(resourceSnake) > 1 {
		return strings.TrimSuffix(resourceSnake, "s")
	}
	return resourceSnake
}

// generateGraphQLIntegration генерирует GraphQL адаптер и схему
func (g *PresentationGenerator) generateGraphQLIntegration(spec *ParsedSpec, config *GeneratorConfig) error {
	// Генерация GraphQL схемы через GraphQLSchemaGenerator
	graphqlGen := NewGraphQLSchemaGenerator(g.outputDir)
	if err := graphqlGen.Generate(spec, config); err != nil {
		return fmt.Errorf("failed to generate GraphQL schema: %w", err)
	}

	// Генерация GraphQL адаптера
	if err := g.generateGraphQLAdapter(spec, config); err != nil {
		return fmt.Errorf("failed to generate GraphQL adapter: %w", err)
	}

	return nil
}

// generateGraphQLAdapter генерирует GraphQL адаптер для интеграции с CQRS
func (g *PresentationGenerator) generateGraphQLAdapter(spec *ParsedSpec, config *GeneratorConfig) error {
	if config == nil {
		config = &GeneratorConfig{}
	}
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package graphql\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\n")
	content.WriteString("\t\"github.com/99designs/gqlgen/graphql\"\n")
	content.WriteString(fmt.Sprintf("\t\"%s/config\"\n", config.ModulePath))
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/events\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\tgraphqltransport \"%s/framework/adapters/transport\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	content.WriteString("// NewGraphQLAdapter создает и настраивает GraphQL адаптер с интеграцией CQRS\n")
	content.WriteString("func NewGraphQLAdapter(\n")
	content.WriteString("\tcfg *config.Config,\n")
	content.WriteString("\tcommandBus transport.CommandBus,\n")
	content.WriteString("\tqueryBus transport.QueryBus,\n")
	content.WriteString("\teventBus events.EventBus,\n")
	content.WriteString("\texecutableSchema graphql.ExecutableSchema,\n")
	content.WriteString(") (*graphqltransport.GraphQLAdapter, error) {\n")
	content.WriteString("\tgraphQLConfig := graphqltransport.DefaultGraphQLConfig()\n")
	content.WriteString("\tgraphQLConfig.Port = cfg.GraphQL.Port\n")
	content.WriteString("\tgraphQLConfig.EnablePlayground = cfg.GraphQL.EnablePlayground\n")
	content.WriteString("\tgraphQLConfig.EnableIntrospection = cfg.GraphQL.EnableIntrospection\n")
	content.WriteString("\tgraphQLConfig.ComplexityLimit = cfg.GraphQL.ComplexityLimit\n")
	content.WriteString("\tgraphQLConfig.MaxDepth = cfg.GraphQL.MaxDepth\n\n")
	content.WriteString("\tadapter, err := graphqltransport.NewGraphQLAdapterWithCQRS(\n")
	content.WriteString("\t\tgraphQLConfig,\n")
	content.WriteString("\t\tcommandBus,\n")
	content.WriteString("\t\tqueryBus,\n")
	content.WriteString("\t\teventBus,\n")
	content.WriteString("\t\texecutableSchema,\n")
	content.WriteString("\t)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"failed to create GraphQL adapter: %w\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Автоматическая регистрация резолверов происходит автоматически при вызове adapter.Start()\n")
	content.WriteString("\t// Нет необходимости вызывать AutoRegisterResolvers() вручную\n\n")
	content.WriteString("\treturn adapter, nil\n")
	content.WriteString("}\n")

	path := "presentation/graphql/adapter.gen.go"
	if err := g.writer.WriteFile(path, content.String()); err != nil {
		return err
	}

	// Генерация пользовательского файла для расширения GraphQL адаптера
	return g.generateGraphQLAdapterUserCode(config)
}

// generateGraphQLAdapterUserCode генерирует пользовательский файл для расширения GraphQL адаптера
func (g *PresentationGenerator) generateGraphQLAdapterUserCode(config *GeneratorConfig) error {
	var userContent strings.Builder

	userContent.WriteString("package graphql\n\n")
	userContent.WriteString("// Этот файл предназначен для расширения функциональности GraphQL адаптера.\n")
	userContent.WriteString("// Вы можете свободно редактировать этот файл - он не будет перезаписан при регенерации.\n")
	userContent.WriteString("// Здесь вы можете добавить кастомные middleware, расширить конфигурацию, добавить кастомные резолверы и т.д.\n\n")
	userContent.WriteString("import (\n")
	userContent.WriteString("\t// Добавьте необходимые импорты\n")
	userContent.WriteString(")\n\n")
	userContent.WriteString("// Пример расширения функциональности:\n")
	userContent.WriteString("// func CustomGraphQLMiddleware(adapter *graphqltransport.GraphQLAdapter) {\n")
	userContent.WriteString("//     // Добавьте вашу кастомную логику\n")
	userContent.WriteString("// }\n\n")
	userContent.WriteString("// Пример кастомной конфигурации:\n")
	userContent.WriteString("// func CustomizeGraphQLConfig(cfg *graphqltransport.GraphQLConfig) {\n")
	userContent.WriteString("//     // Кастомизируйте конфигурацию\n")
	userContent.WriteString("// }\n")

	userPath := "presentation/graphql/adapter.go"
	return g.writer.WriteFile(userPath, userContent.String())
}

// protoToGoType конвертирует proto тип в Go тип
func (g *PresentationGenerator) protoToGoType(protoType string, repeated bool) string {
	var goType string
	switch protoType {
	case "string":
		goType = "string"
	case "int32":
		goType = "int32"
	case "int64":
		goType = "int64"
	case "bool":
		goType = "bool"
	case "float64":
		goType = "float64"
	case "float32":
		goType = "float32"
	case "[]byte":
		goType = "[]byte"
	default:
		// Для пользовательских типов (например, Item) возвращаем как есть
		goType = protoType
	}
	
	// Если поле repeated, добавляем слайс
	if repeated {
		return "[]" + goType
	}
	return goType
}

// toPublicField конвертирует имя поля в публичное (с заглавной буквы)
func (g *PresentationGenerator) toPublicField(name string) string {
	if len(name) == 0 {
		return name
	}
	// Конвертируем snake_case в CamelCase
	parts := strings.Split(name, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]) + part[1:])
		}
	}
	return result.String()
}
