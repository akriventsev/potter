package codegen

import (
	"fmt"
	"strings"
)

// InfrastructureGenerator генератор infrastructure слоя
type InfrastructureGenerator struct {
	*BaseGenerator
}

// NewInfrastructureGenerator создает новый генератор infrastructure слоя
func NewInfrastructureGenerator(outputDir string) *InfrastructureGenerator {
	return &InfrastructureGenerator{
		BaseGenerator: NewBaseGenerator("infrastructure", outputDir),
	}
}

// Generate генерирует infrastructure слой
func (g *InfrastructureGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateRepositories(spec, config); err != nil {
		return fmt.Errorf("failed to generate repositories: %w", err)
	}

	if err := g.generateCacheService(spec, config); err != nil {
		return fmt.Errorf("failed to generate cache service: %w", err)
	}

	if err := g.generateMigrations(spec, config); err != nil {
		return fmt.Errorf("failed to generate migrations: %w", err)
	}

	if err := g.generateConfig(spec, config); err != nil {
		return fmt.Errorf("failed to generate config: %w", err)
	}

	return nil
}

// generateRepositories генерирует реализации репозиториев
func (g *InfrastructureGenerator) generateRepositories(spec *ParsedSpec, config *GeneratorConfig) error {
	for _, agg := range spec.Aggregates {
		if err := g.generateRepository(agg, config); err != nil {
			return fmt.Errorf("failed to generate repository for %s: %w", agg.Name, err)
		}
	}
	return nil
}

// generateRepository генерирует реализацию репозитория
func (g *InfrastructureGenerator) generateRepository(agg AggregateSpec, config *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package repository\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"time\"\n")
	content.WriteString("\n")
	content.WriteString("\t\"github.com/jackc/pgx/v5\"\n")
	content.WriteString("\t\"github.com/jackc/pgx/v5/pgxpool\"\n")
	content.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/cache\"\n", config.ModulePath))
	content.WriteString(")\n\n")

	repoName := fmt.Sprintf("Postgres%sRepository", agg.Name)
	content.WriteString(fmt.Sprintf("// %s реализация %sRepository с использованием PostgreSQL\n",
		repoName, agg.Name))
	content.WriteString(fmt.Sprintf("type %s struct {\n", repoName))
	content.WriteString("\tdb    *pgxpool.Pool\n")
	content.WriteString("\tcache cache.CacheService\n")
	content.WriteString("\ttable string\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("// New%s создает новый PostgreSQL репозиторий\n", repoName))
	content.WriteString(fmt.Sprintf("func New%s(db *pgxpool.Pool, cache cache.CacheService) *%s {\n",
		repoName, repoName))
	content.WriteString(fmt.Sprintf("\treturn &%s{\n", repoName))
	content.WriteString("\t\tdb:    db,\n")
	content.WriteString("\t\tcache: cache,\n")
	content.WriteString(fmt.Sprintf("\t\ttable: %q,\n", g.converter.ToSnakeCase(agg.Name)+"s"))
	content.WriteString("\t}\n")
	content.WriteString("}\n\n")

	// Save метод
	content.WriteString(fmt.Sprintf("// Save сохраняет %s в Postgres + инвалидация кеша\n", strings.ToLower(agg.Name)))
	content.WriteString(fmt.Sprintf("func (r *%s) Save(ctx context.Context, %s *domain.%s) error {\n",
		repoName, strings.ToLower(agg.Name), agg.Name))
	// Подсчет полей (без id)
	nonIDFields := 0
	for _, field := range agg.Fields {
		if field.Name != "id" {
			nonIDFields++
		}
	}

	// Параметры: id ($1), поля ($2..$N+1), created_at ($N+2), updated_at ($N+3)
	// Для UPDATE: те же поля, но created_at не обновляется, updated_at последний

	createdAtIdx := 2 + nonIDFields
	updatedAtIdx := createdAtIdx + 1

	content.WriteString("// USER CODE BEGIN: SaveSQL\n")

	// Формируем список полей для INSERT
	var insertFields []string
	var insertPlaceholders []string
	insertFields = append(insertFields, "id")
	insertPlaceholders = append(insertPlaceholders, "$1")
	paramIdx := 2
	for _, field := range agg.Fields {
		if field.Name == "id" {
			continue
		}
		insertFields = append(insertFields, g.converter.ToSnakeCase(field.Name))
		insertPlaceholders = append(insertPlaceholders, fmt.Sprintf("$%d", paramIdx))
		paramIdx++
	}
	insertFields = append(insertFields, "created_at", "updated_at")
	insertPlaceholders = append(insertPlaceholders, fmt.Sprintf("$%d", createdAtIdx), fmt.Sprintf("$%d", updatedAtIdx))

	// Формируем UPDATE SET часть
	var updates []string
	updateParamIdx := 2 // Начинаем с поля после id
	for _, field := range agg.Fields {
		if field.Name == "id" || field.Name == "created_at" {
			continue
		}
		updates = append(updates, fmt.Sprintf("%s = $%d", g.converter.ToSnakeCase(field.Name), updateParamIdx))
		updateParamIdx++
	}
	updates = append(updates, fmt.Sprintf("updated_at = $%d", updatedAtIdx))

	queryTemplate := "\tquery := fmt.Sprintf(`\n" +
		"\t\tINSERT INTO %s (" + strings.Join(insertFields, ", ") + ") \n" +
		"\t\tVALUES (" + strings.Join(insertPlaceholders, ", ") + ")\n" +
		"\t\tON CONFLICT (id) \n" +
		"\t\tDO UPDATE SET " + strings.Join(updates, ", ") + "\n" +
		"\t`, r.table)\n"
	content.WriteString(queryTemplate)
	content.WriteString("// USER CODE END: SaveSQL\n\n")
	content.WriteString("\t_, err := r.db.Exec(ctx, query,\n")
	content.WriteString(fmt.Sprintf("\t\t%s.ID(),\n", strings.ToLower(agg.Name)))
	for _, field := range agg.Fields {
		if field.Name == "id" {
			continue
		}
		content.WriteString(fmt.Sprintf("\t\t%s.%s(),\n",
			strings.ToLower(agg.Name), g.toPublicField(field.Name)))
	}
	content.WriteString(fmt.Sprintf("\t\t%s.CreatedAt(),\n", strings.ToLower(agg.Name)))
	content.WriteString(fmt.Sprintf("\t\t%s.UpdatedAt(),\n", strings.ToLower(agg.Name)))
	content.WriteString("\t)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to save %s: %%w\", err)\n", strings.ToLower(agg.Name)))
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Инвалидация кеша\n")
	content.WriteString(fmt.Sprintf("\t_ = r.cache.Delete(ctx, fmt.Sprintf(\"%s:%%s\", %s.ID()))\n",
		strings.ToLower(agg.Name), strings.ToLower(agg.Name)))
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n\n")

	// FindByID метод
	content.WriteString(fmt.Sprintf("// FindByID находит %s по ID\n", strings.ToLower(agg.Name)))
	content.WriteString(fmt.Sprintf("func (r *%s) FindByID(ctx context.Context, id string) (*domain.%s, error) {\n",
		repoName, agg.Name))
	content.WriteString("\tquery := fmt.Sprintf(\"SELECT ")
	var selectFields []string
	for _, field := range agg.Fields {
		if field.Name == "id" {
			continue
		}
		selectFields = append(selectFields, g.converter.ToSnakeCase(field.Name))
	}
	selectFields = append(selectFields, "created_at", "updated_at")
	content.WriteString(strings.Join(selectFields, ", "))
	content.WriteString(fmt.Sprintf(" FROM %%s WHERE id = $1\", r.table)\n\n"))

	// Генерируем объявления переменных с правильными переносами
	for _, field := range agg.Fields {
		if field.Name == "id" {
			continue
		}
		content.WriteString(fmt.Sprintf("\tvar %s %s\n",
			g.toPrivateField(field.Name), g.protoToGoType(field.Type)))
	}
	content.WriteString("\tvar createdAt, updatedAt time.Time\n")
	content.WriteString("\terr := r.db.QueryRow(ctx, query, id).Scan(")
	var scanArgs []string
	for _, field := range agg.Fields {
		if field.Name == "id" {
			continue
		}
		scanArgs = append(scanArgs, "&"+g.toPrivateField(field.Name))
	}
	scanArgs = append(scanArgs, "&createdAt", "&updatedAt")
	content.WriteString(strings.Join(scanArgs, ", "))
	content.WriteString(")\n")
	content.WriteString("\tif err == pgx.ErrNoRows {\n")
	content.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"%s not found: %%s\", id)\n", strings.ToLower(agg.Name)))
	content.WriteString("\t}\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"failed to find %s: %%w\", err)\n", strings.ToLower(agg.Name)))
	content.WriteString("\t}\n\n")
	content.WriteString(fmt.Sprintf("\treturn domain.New%sWithState(id", agg.Name))
	for _, field := range agg.Fields {
		if field.Name == "id" {
			continue
		}
		content.WriteString(fmt.Sprintf(", %s", g.toPrivateField(field.Name)))
	}
	content.WriteString(", createdAt, updatedAt), nil\n")
	content.WriteString("}\n\n")

	// Delete метод
	content.WriteString(fmt.Sprintf("// Delete удаляет %s + инвалидация кеша\n", strings.ToLower(agg.Name)))
	content.WriteString(fmt.Sprintf("func (r *%s) Delete(ctx context.Context, id string) error {\n", repoName))
	content.WriteString(fmt.Sprintf("\tquery := fmt.Sprintf(\"DELETE FROM %%s WHERE id = $1\", r.table)\n\n"))
	content.WriteString("\tresult, err := r.db.Exec(ctx, query, id)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to delete %s: %%w\", err)\n", strings.ToLower(agg.Name)))
	content.WriteString("\t}\n\n")
	content.WriteString("\tif result.RowsAffected() == 0 {\n")
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s not found: %%s\", id)\n", strings.ToLower(agg.Name)))
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Инвалидация кеша\n")
	content.WriteString(fmt.Sprintf("\t_ = r.cache.Delete(ctx, fmt.Sprintf(\"%s:%%s\", id))\n", strings.ToLower(agg.Name)))
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n")

	path := fmt.Sprintf("infrastructure/repository/%s_repository.go", g.converter.ToSnakeCase(agg.Name))
	return g.writer.WriteFile(path, content.String())
}

// generateCacheService генерирует cache service
func (g *InfrastructureGenerator) generateCacheService(_ *ParsedSpec, _ *GeneratorConfig) error {
	// Копируем структуру из примера
	content := `// Code generated by potter-gen. DO NOT EDIT.

package cache

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
)

// CacheService интерфейс для работы с кешем
type CacheService interface {
	Get(ctx context.Context, key string, dest interface{}) (bool, error)
	Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
	Delete(ctx context.Context, key string) error
	Exists(ctx context.Context, key string) (bool, error)
}

// RedisCacheService реализация CacheService с использованием Redis
type RedisCacheService struct {
	client *redis.Client
}

// NewRedisCacheService создает новый Redis кеш сервис
func NewRedisCacheService(client *redis.Client) *RedisCacheService {
	return &RedisCacheService{
		client: client,
	}
}

// Get получает значение по ключу с десериализацией из JSON
func (r *RedisCacheService) Get(ctx context.Context, key string, dest interface{}) (bool, error) {
	data, err := r.client.Get(ctx, key).Result()
	if err == redis.Nil {
		return false, nil
	}
	if err != nil {
		return false, fmt.Errorf("failed to get from cache: %w", err)
	}

	if err := json.Unmarshal([]byte(data), dest); err != nil {
		return false, fmt.Errorf("failed to unmarshal cache value: %w", err)
	}

	return true, nil
}

// Set сохраняет значение с сериализацией в JSON и TTL
func (r *RedisCacheService) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
	data, err := json.Marshal(value)
	if err != nil {
		return fmt.Errorf("failed to marshal cache value: %w", err)
	}

	if err := r.client.Set(ctx, key, data, ttl).Err(); err != nil {
		return fmt.Errorf("failed to set cache value: %w", err)
	}

	return nil
}

// Delete удаляет ключ
func (r *RedisCacheService) Delete(ctx context.Context, key string) error {
	if err := r.client.Del(ctx, key).Err(); err != nil {
		return fmt.Errorf("failed to delete cache key: %w", err)
	}
	return nil
}

// Exists проверяет существование ключа
func (r *RedisCacheService) Exists(ctx context.Context, key string) (bool, error) {
	count, err := r.client.Exists(ctx, key).Result()
	if err != nil {
		return false, fmt.Errorf("failed to check cache key existence: %w", err)
	}
	return count > 0, nil
}
`

	path := "infrastructure/cache/redis_cache.go"
	return g.writer.WriteFile(path, content)
}

// generateMigrations генерирует SQL миграции в формате goose (единый файл с аннотациями -- +goose Up/Down)
func (g *InfrastructureGenerator) generateMigrations(spec *ParsedSpec, _ *GeneratorConfig) error {
	var content strings.Builder

	// Заголовок миграции
	content.WriteString("-- +goose Up\n")
	content.WriteString("-- Migration: Create tables and indexes\n")
	content.WriteString("-- Generated by potter-gen\n\n")

	// Собираем информацию о таблицах и индексах для down миграции
	type tableInfo struct {
		tableName string
		indexes   []string
	}
	var tables []tableInfo

	// Генерация UP миграции
	for _, agg := range spec.Aggregates {
		tableName := g.converter.ToSnakeCase(agg.Name) + "s"
		indexName := fmt.Sprintf("idx_%s_id", tableName)

		// CREATE TABLE
		content.WriteString(fmt.Sprintf("-- Таблица %s\n", strings.ToLower(agg.Name)))
		content.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (\n", tableName))
		content.WriteString("\tid VARCHAR(255) PRIMARY KEY,\n")

		for _, field := range agg.Fields {
			if field.Name == "id" {
				continue
			}
			sqlType := g.protoToSQLType(field.Type)
			content.WriteString(fmt.Sprintf("\t%s %s", g.converter.ToSnakeCase(field.Name), sqlType))
			if field.Name == "id" || !field.Optional {
				content.WriteString(" NOT NULL")
			}
			content.WriteString(",\n")
		}

		content.WriteString("\tcreated_at TIMESTAMP NOT NULL DEFAULT NOW(),\n")
		content.WriteString("\tupdated_at TIMESTAMP NOT NULL DEFAULT NOW()\n")
		content.WriteString(");\n\n")

		// CREATE INDEX
		content.WriteString(fmt.Sprintf("-- Индексы для таблицы %s\n", tableName))
		content.WriteString(fmt.Sprintf("CREATE INDEX IF NOT EXISTS %s ON %s(id);\n\n",
			indexName, tableName))

		// Сохраняем информацию для down миграции
		tables = append(tables, tableInfo{
			tableName: tableName,
			indexes:   []string{indexName},
		})
	}

	// Разделитель между UP и DOWN
	content.WriteString("\n-- +goose Down\n")
	content.WriteString("-- Migration: Drop tables and indexes\n")
	content.WriteString("-- Generated by potter-gen\n\n")

	// Генерация DOWN миграции (в обратном порядке)
	for i := len(tables) - 1; i >= 0; i-- {
		table := tables[i]
		// Сначала удаляем индексы
		for j := len(table.indexes) - 1; j >= 0; j-- {
			content.WriteString(fmt.Sprintf("DROP INDEX IF EXISTS %s;\n", table.indexes[j]))
		}
		// Затем удаляем таблицу
		content.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS %s;\n\n", table.tableName))
	}

	// Записываем единый файл миграции в формате goose
	migrationPath := "migrations/001_create_tables.sql"
	if err := g.writer.WriteFile(migrationPath, content.String()); err != nil {
		return fmt.Errorf("failed to write migration: %w", err)
	}

	return nil
}

// generateConfig генерирует конфигурацию
func (g *InfrastructureGenerator) generateConfig(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `// Code generated by potter-gen. DO NOT EDIT.

package config

import (
	"os"
	"strconv"
)

// Config конфигурация приложения
type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
	Redis    RedisConfig
	NATS     NATSConfig
	Metrics  MetricsConfig
	GraphQL  GraphQLConfig
}

// ServerConfig конфигурация сервера
type ServerConfig struct {
	Port int
}

// DatabaseConfig конфигурация базы данных
type DatabaseConfig struct {
	DSN string
}

// RedisConfig конфигурация Redis
type RedisConfig struct {
	Addr     string
	Password string
	DB       int
}

// NATSConfig конфигурация NATS
type NATSConfig struct {
	URL string
}

// MetricsConfig конфигурация метрик
type MetricsConfig struct {
	Enabled bool
	Port    int
}

// GraphQLConfig конфигурация GraphQL
type GraphQLConfig struct {
	Port              int
	EnablePlayground  bool
	EnableIntrospection bool
	ComplexityLimit   int
	MaxDepth          int
}

// LoadConfig загружает конфигурацию из переменных окружения
func LoadConfig() *Config {
	return &Config{
		Server: ServerConfig{
			Port: getEnvAsInt("SERVER_PORT", 8080),
		},
		Database: DatabaseConfig{
			DSN: getEnv("DATABASE_DSN", "postgres://postgres:postgres@localhost:5432/db?sslmode=disable"),
		},
		Redis: RedisConfig{
			Addr:     getEnv("REDIS_ADDR", "localhost:6379"),
			Password: getEnv("REDIS_PASSWORD", ""),
			DB:       getEnvAsInt("REDIS_DB", 0),
		},
		NATS: NATSConfig{
			URL: getEnv("NATS_URL", "nats://localhost:4222"),
		},
		Metrics: MetricsConfig{
			Enabled: getEnvAsBool("METRICS_ENABLED", true),
			Port:    getEnvAsInt("METRICS_PORT", 2112),
		},
		GraphQL: GraphQLConfig{
			Port:                getEnvAsInt("GRAPHQL_PORT", 8082),
			EnablePlayground:   getEnvAsBool("GRAPHQL_PLAYGROUND_ENABLED", true),
			EnableIntrospection: getEnvAsBool("GRAPHQL_INTROSPECTION_ENABLED", true),
			ComplexityLimit:     getEnvAsInt("GRAPHQL_COMPLEXITY_LIMIT", 1000),
			MaxDepth:            getEnvAsInt("GRAPHQL_MAX_DEPTH", 15),
		},
	}
}

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}

func getEnvAsBool(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return defaultValue
}
`

	path := "config/config.go"
	return g.writer.WriteFile(path, content)
}

// protoToGoType конвертирует proto тип в Go тип
func (g *InfrastructureGenerator) protoToGoType(protoType string) string {
	switch protoType {
	case "string":
		return "string"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "bool":
		return "bool"
	case "float64":
		return "float64"
	case "float32":
		return "float32"
	default:
		return protoType
	}
}

// protoToSQLType конвертирует proto тип в SQL тип
func (g *InfrastructureGenerator) protoToSQLType(protoType string) string {
	switch protoType {
	case "string":
		return "VARCHAR(255)"
	case "int32", "int64":
		return "INTEGER"
	case "bool":
		return "BOOLEAN"
	case "float64", "float32":
		return "DOUBLE PRECISION"
	default:
		return "TEXT"
	}
}

// toPublicField конвертирует имя поля в публичное
func (g *InfrastructureGenerator) toPublicField(name string) string {
	if len(name) == 0 {
		return name
	}
	return strings.ToUpper(name[:1]) + name[1:]
}

// toPrivateField конвертирует имя поля в приватное
func (g *InfrastructureGenerator) toPrivateField(name string) string {
	if len(name) == 0 {
		return name
	}
	return strings.ToLower(name[:1]) + name[1:]
}
