package codegen

import (
	"fmt"
	"strings"
)

// ApplicationGenerator генератор application слоя
type ApplicationGenerator struct {
	*BaseGenerator
}

// NewApplicationGenerator создает новый генератор application слоя
func NewApplicationGenerator(outputDir string) *ApplicationGenerator {
	return &ApplicationGenerator{
		BaseGenerator: NewBaseGenerator("application", outputDir),
	}
}

// Generate генерирует application слой
func (g *ApplicationGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateCommands(spec, config); err != nil {
		return fmt.Errorf("failed to generate commands: %w", err)
	}

	if err := g.generateQueries(spec, config); err != nil {
		return fmt.Errorf("failed to generate queries: %w", err)
	}

	return nil
}

// generateCommands генерирует команды и handlers
func (g *ApplicationGenerator) generateCommands(spec *ParsedSpec, config *GeneratorConfig) error {
	for _, cmd := range spec.Commands {
		if err := g.generateCommand(cmd, spec, config); err != nil {
			return fmt.Errorf("failed to generate command %s: %w", cmd.Name, err)
		}
	}
	return nil
}

// generateCommand генерирует команду и handler
func (g *ApplicationGenerator) generateCommand(cmd CommandSpec, _ *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package command\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\n")
	if config != nil && config.ModulePath != "" {
		content.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	} else {
		content.WriteString("\t\"domain\"\n")
	}
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/events\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/invoke\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	// Генерация команды
	cmdName := fmt.Sprintf("%sCommand", cmd.Name)
	content.WriteString(fmt.Sprintf("// %s команда\n", cmdName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", cmdName))

	// Поля из request типа (упрощенно - в реальности нужно парсить proto message)
	content.WriteString("\t// Add fields from request message\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (c %s) CommandName() string {\n", cmdName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(cmd.Name)))
	content.WriteString("}\n\n")

	// Генерация handler
	handlerName := fmt.Sprintf("%sHandler", cmd.Name)
	content.WriteString(fmt.Sprintf("// %s обработчик команды\n", handlerName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", handlerName))

	// Находим репозиторий для агрегата
	repoName := fmt.Sprintf("%sRepository", cmd.Aggregate)
	repoVarName := strings.ToLower(cmd.Aggregate) + "Repo"
	content.WriteString(fmt.Sprintf("\t%s domain.%s\n", repoVarName, repoName))
	content.WriteString("\teventPublisher events.EventPublisher\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("// New%s создает новый обработчик\n", handlerName))
	content.WriteString(fmt.Sprintf("func New%s(%s domain.%s, eventPublisher events.EventPublisher) *%s {\n",
		handlerName, repoVarName, repoName, handlerName))
	content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
	content.WriteString(fmt.Sprintf("\t\t%s: %s,\n", repoVarName, repoVarName))
	content.WriteString("\t\teventPublisher: eventPublisher,\n")
	content.WriteString("\t}\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) Handle(ctx context.Context, cmd transport.Command) error {\n", handlerName))
	content.WriteString(fmt.Sprintf("\t%s, ok := cmd.(%s)\n", strings.ToLower(cmd.Name), cmdName))
	content.WriteString("\tif !ok {\n")
	content.WriteString("\t\treturn fmt.Errorf(\"invalid command type: %T\", cmd)\n")
	content.WriteString("\t}\n\n")

	// Вызов пользовательской функции валидации
	validationFuncName := fmt.Sprintf("validate%s", cmd.Name)
	content.WriteString(fmt.Sprintf("\t// Валидация команды\n"))
	content.WriteString(fmt.Sprintf("\tif err := %s(ctx, %s); err != nil {\n", validationFuncName, strings.ToLower(cmd.Name)))
	content.WriteString("\t\treturn fmt.Errorf(\"validation failed: %w\", err)\n")
	content.WriteString("\t}\n\n")

	// Вызов пользовательской функции бизнес-логики
	businessLogicFuncName := fmt.Sprintf("execute%sBusinessLogic", cmd.Name)
	content.WriteString(fmt.Sprintf("\t// Выполнение бизнес-логики\n"))
	content.WriteString(fmt.Sprintf("\t%s, err := %s(ctx, h.%s, %s)\n",
		strings.ToLower(cmd.Aggregate), businessLogicFuncName, repoVarName, strings.ToLower(cmd.Name)))
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn fmt.Errorf(\"business logic failed: %w\", err)\n")
	content.WriteString("\t}\n\n")

	// Сохранение и публикация событий
	content.WriteString(fmt.Sprintf("\t// Сохранение %s\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("\tif err := h.%s.Save(ctx, %s); err != nil {\n",
		repoVarName, strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to save %s: %%w\", err)\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\t}\n\n")

	content.WriteString("\t// Извлекаем correlation ID из контекста\n")
	content.WriteString("\tcorrelationID := invoke.ExtractCorrelationID(ctx)\n")
	content.WriteString("\tcausationID := invoke.ExtractCausationID(ctx)\n\n")

	content.WriteString("\t// Публикация событий с correlation ID\n")
	content.WriteString(fmt.Sprintf("\tfor _, event := range %s.Events() {\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\t\tif correlationID != \"\" {\n")
	content.WriteString("\t\t\tevent.Metadata().Set(\"correlation_id\", correlationID)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif causationID != \"\" {\n")
	content.WriteString("\t\t\tevent.Metadata().Set(\"causation_id\", causationID)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif err := h.eventPublisher.Publish(ctx, event); err != nil {\n")
	content.WriteString("\t\t\treturn fmt.Errorf(\"failed to publish event: %w\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}\n")
	content.WriteString(fmt.Sprintf("\t%s.ClearEvents()\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\n")
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) CommandName() string {\n", handlerName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(cmd.Name)))
	content.WriteString("}\n")

	path := fmt.Sprintf("application/command/%s.gen.go", g.converter.ToSnakeCase(cmd.Name))
	if err := g.writer.WriteFile(path, content.String()); err != nil {
		return err
	}

	// Генерация отдельного файла для пользовательского кода
	return g.generateCommandUserCode(cmd, config)
}

// generateCommandUserCode генерирует отдельный файл для пользовательского кода команды
func (g *ApplicationGenerator) generateCommandUserCode(cmd CommandSpec, config *GeneratorConfig) error {
	var userContent strings.Builder

	userContent.WriteString("package command\n\n")
	userContent.WriteString(fmt.Sprintf("// Этот файл содержит пользовательский код для команды %s.\n", cmd.Name))
	userContent.WriteString("// Вы можете свободно редактировать этот файл - он не будет перезаписан при регенерации.\n\n")
	userContent.WriteString("import (\n")
	userContent.WriteString("\t\"context\"\n")
	userContent.WriteString("\t\"fmt\"\n")
	userContent.WriteString("\n")
	if config != nil && config.ModulePath != "" {
		userContent.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	} else {
		userContent.WriteString("\t\"domain\"\n")
	}
	// Импорт transport не нужен в пользовательском коде команды
	userContent.WriteString(")\n\n")

	// Функция валидации
	cmdName := fmt.Sprintf("%sCommand", cmd.Name)
	validationFuncName := fmt.Sprintf("validate%s", cmd.Name)
	userContent.WriteString(fmt.Sprintf("// %s валидирует команду %s\n", validationFuncName, cmd.Name))
	userContent.WriteString(fmt.Sprintf("// Реализуйте валидацию входных данных здесь\n"))
	userContent.WriteString(fmt.Sprintf("func %s(ctx context.Context, cmd %s) error {\n", validationFuncName, cmdName))
	userContent.WriteString("\t// TODO: Add validation logic here\n")
	userContent.WriteString("\t// Example:\n")
	userContent.WriteString("\t// if cmd.Name == \"\" {\n")
	userContent.WriteString("\t//     return fmt.Errorf(\"name is required\")\n")
	userContent.WriteString("\t// }\n")
	userContent.WriteString("\treturn nil\n")
	userContent.WriteString("}\n\n")

	// Функция бизнес-логики
	businessLogicFuncName := fmt.Sprintf("execute%sBusinessLogic", cmd.Name)
	repoName := fmt.Sprintf("%sRepository", cmd.Aggregate)
	userContent.WriteString(fmt.Sprintf("// %s выполняет бизнес-логику команды %s\n", businessLogicFuncName, cmd.Name))
	userContent.WriteString(fmt.Sprintf("// Реализуйте создание и изменение агрегата здесь\n"))
	userContent.WriteString(fmt.Sprintf("// Возвращает созданный/измененный агрегат %s\n", cmd.Aggregate))
	userContent.WriteString(fmt.Sprintf("func %s(ctx context.Context, repo domain.%s, cmd %s) (*domain.%s, error) {\n",
		businessLogicFuncName, repoName, cmdName, cmd.Aggregate))
	userContent.WriteString("\t// TODO: Implement business logic here\n")
	userContent.WriteString(fmt.Sprintf("\t// Example: Create %s aggregate\n", strings.ToLower(cmd.Aggregate)))
	userContent.WriteString(fmt.Sprintf("\t// %s := domain.New%s(\n", strings.ToLower(cmd.Aggregate), cmd.Aggregate))
	userContent.WriteString("\t//     cmd.Name,\n")
	userContent.WriteString("\t//     cmd.Description,\n")
	userContent.WriteString("\t//     cmd.Quantity,\n")
	userContent.WriteString("\t// )\n")
	userContent.WriteString(fmt.Sprintf("\t// return %s, nil\n", strings.ToLower(cmd.Aggregate)))
	userContent.WriteString("\treturn nil, fmt.Errorf(\"not implemented\")\n")
	userContent.WriteString("}\n")

	userPath := fmt.Sprintf("application/command/%s.go", g.converter.ToSnakeCase(cmd.Name))
	return g.writer.WriteFile(userPath, userContent.String())
}

// generateQueries генерирует запросы и handlers
func (g *ApplicationGenerator) generateQueries(spec *ParsedSpec, config *GeneratorConfig) error {
	for _, query := range spec.Queries {
		if err := g.generateQuery(query, spec, config); err != nil {
			return fmt.Errorf("failed to generate query %s: %w", query.Name, err)
		}
	}
	return nil
}

// generateQuery генерирует запрос, response и handler
func (g *ApplicationGenerator) generateQuery(query QuerySpec, spec *ParsedSpec, config *GeneratorConfig) error {
	if config == nil {
		config = &GeneratorConfig{}
	}
	var content strings.Builder

	// Определяем, используется ли domain репозиторий
	hasReadModel := query.ReadModel != ""
	var usesDomain bool
	var foundAggregate *AggregateSpec
	if !hasReadModel {
		aggregateName := inferAggregateFromQueryName(query.Name)
		if aggregateName != "" {
			// Ищем агрегат в спецификации - только если найден, используем domain
			foundAggregate = findAggregateByName(spec.Aggregates, aggregateName)
			usesDomain = foundAggregate != nil
		}
	}

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package query\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	// Импорт time добавляется только если query cacheable
	if query.Cacheable {
		content.WriteString("\t\"time\"\n")
	}
	content.WriteString("\n")
	if usesDomain {
		content.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	}
	if query.Cacheable {
		content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/cache\"\n", config.ModulePath))
	}
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	// Генерация запроса
	queryName := fmt.Sprintf("%sQuery", query.Name)
	content.WriteString(fmt.Sprintf("// %s запрос\n", queryName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", queryName))
	content.WriteString("\t// Add fields from request message\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (q %s) QueryName() string {\n", queryName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(query.Name)))
	content.WriteString("}\n\n")

	// Генерация response
	responseName := fmt.Sprintf("%sResponse", query.Name)
	content.WriteString(fmt.Sprintf("// %s ответ на запрос\n", responseName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", responseName))
	content.WriteString("\t// Add fields from response message\n")
	content.WriteString("}\n\n")

	// Генерация handler
	handlerName := fmt.Sprintf("%sHandler", query.Name)
	content.WriteString(fmt.Sprintf("// %s обработчик запроса\n", handlerName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", handlerName))

	// Определяем какой репозиторий использовать
	if hasReadModel {
		// Query использует read model - НЕ добавляем поле репозитория агрегата
		content.WriteString(fmt.Sprintf("\t// This query uses read model: %s\n", query.ReadModel))
		content.WriteString("\t// TODO: Add read-model repository field here if needed\n")
	} else {
		// Query НЕ использует read model - определяем агрегат из имени query
		if foundAggregate != nil {
			// Агрегат найден в спецификации - добавляем поле репозитория
			repoName := fmt.Sprintf("%sRepository", foundAggregate.Name)
			repoVarName := strings.ToLower(foundAggregate.Name) + "Repo"
			content.WriteString(fmt.Sprintf("\t%s domain.%s\n", repoVarName, repoName))
		} else {
			// Агрегат не найден в спецификации - добавляем TODO комментарий
			content.WriteString("\t// TODO: Add repository field here based on your query data source\n")
			aggregateName := inferAggregateFromQueryName(query.Name)
			if aggregateName != "" {
				content.WriteString(fmt.Sprintf("\t// Inferred aggregate name '%s' was not found in spec.Aggregates\n", aggregateName))
			} else {
				content.WriteString("\t// Cannot automatically determine aggregate from query name\n")
			}
		}
	}

	if query.Cacheable {
		content.WriteString("\tcache cache.CacheService\n")
	}
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("// New%s создает новый обработчик\n", handlerName))

	// Генерируем конструктор в зависимости от наличия read_model и агрегата
	if hasReadModel {
		// Query имеет read_model - параметры: только cache (если cacheable)
		content.WriteString(fmt.Sprintf("func New%s(", handlerName))
		if query.Cacheable {
			content.WriteString("cache cache.CacheService")
		}
		content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
		content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
		if query.Cacheable {
			content.WriteString("\t\tcache: cache,\n")
		}
		content.WriteString("\t}\n")
		content.WriteString("}\n\n")
	} else {
		// Query НЕ имеет read_model - определяем агрегат
		if foundAggregate != nil {
			// Агрегат найден в спецификации - добавляем параметр репозитория
			repoName := fmt.Sprintf("%sRepository", foundAggregate.Name)
			repoVarName := strings.ToLower(foundAggregate.Name) + "Repo"

			content.WriteString(fmt.Sprintf("func New%s(%s domain.%s", handlerName, repoVarName, repoName))
			if query.Cacheable {
				content.WriteString(", cache cache.CacheService")
			}
			content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
			content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
			content.WriteString(fmt.Sprintf("\t\t%s: %s,\n", repoVarName, repoVarName))
			if query.Cacheable {
				content.WriteString("\t\tcache: cache,\n")
			}
			content.WriteString("\t}\n")
			content.WriteString("}\n\n")
		} else {
			// Агрегат не найден в спецификации - только cache (если cacheable) и TODO комментарий
			content.WriteString(fmt.Sprintf("// TODO: Add repository parameter(s) to constructor based on your query data source\n"))
			aggregateName := inferAggregateFromQueryName(query.Name)
			if aggregateName != "" {
				content.WriteString(fmt.Sprintf("// Inferred aggregate name '%s' was not found in spec.Aggregates\n", aggregateName))
			}
			content.WriteString(fmt.Sprintf("func New%s(", handlerName))
			if query.Cacheable {
				content.WriteString("cache cache.CacheService")
			}
			content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
			content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
			if query.Cacheable {
				content.WriteString("\t\tcache: cache,\n")
			}
			content.WriteString("\t}\n")
			content.WriteString("}\n\n")
		}
	}

	content.WriteString(fmt.Sprintf("func (h *%s) Handle(ctx context.Context, q transport.Query) (interface{}, error) {\n", handlerName))
	content.WriteString(fmt.Sprintf("\t%s, ok := q.(%s)\n", strings.ToLower(query.Name), queryName))
	content.WriteString("\tif !ok {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"invalid query type: %T\", q)\n")
	content.WriteString("\t}\n\n")

	if query.Cacheable {
		// Генерация cache key через пользовательскую функцию
		content.WriteString("\t// Попытка получить из кеша\n")
		content.WriteString(fmt.Sprintf("\tcacheKey := build%sCacheKey(%s)\n", query.Name, strings.ToLower(query.Name)))
		content.WriteString(fmt.Sprintf("\tvar response %s\n", responseName))
		content.WriteString("\texists, err := h.cache.Get(ctx, cacheKey, &response)\n")
		content.WriteString("\tif err == nil && exists {\n")
		content.WriteString("\t\treturn response, nil\n")
		content.WriteString("\t}\n\n")
	}

	// Вызов пользовательской функции загрузки данных
	loadDataFuncName := fmt.Sprintf("load%sData", query.Name)
	content.WriteString("\t// Загрузка данных\n")
	if query.Cacheable {
		// Если cacheable, переменные response и err уже объявлены выше
		content.WriteString(fmt.Sprintf("\tresponse, err = %s(ctx, h, %s)\n", loadDataFuncName, strings.ToLower(query.Name)))
	} else {
		// Если не cacheable, нужно объявить переменные
		content.WriteString(fmt.Sprintf("\tresponse, err := %s(ctx, h, %s)\n", loadDataFuncName, strings.ToLower(query.Name)))
	}
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"failed to load data: %w\", err)\n")
	content.WriteString("\t}\n\n")

	if query.Cacheable {
		content.WriteString(fmt.Sprintf("\t// Сохранить в кеш с TTL %d секунд\n", query.CacheTTLSeconds))
		content.WriteString(fmt.Sprintf("\tif err := h.cache.Set(ctx, cacheKey, response, %d*time.Second); err != nil {\n",
			query.CacheTTLSeconds))
		content.WriteString("\t\t// Логируем ошибку, но не прерываем выполнение\n")
		content.WriteString("\t\t_ = err\n")
		content.WriteString("\t}\n\n")
	}

	content.WriteString("\treturn response, nil\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) QueryName() string {\n", handlerName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(query.Name)))
	content.WriteString("}\n")

	path := fmt.Sprintf("application/query/%s.gen.go", g.converter.ToSnakeCase(query.Name))
	if err := g.writer.WriteFile(path, content.String()); err != nil {
		return err
	}

	// Генерация отдельного файла для пользовательского кода
	return g.generateQueryUserCode(query, spec, config)
}

// generateQueryUserCode генерирует отдельный файл для пользовательского кода запроса
func (g *ApplicationGenerator) generateQueryUserCode(query QuerySpec, spec *ParsedSpec, config *GeneratorConfig) error {
	var userContent strings.Builder

	userContent.WriteString("package query\n\n")
	userContent.WriteString(fmt.Sprintf("// Этот файл содержит пользовательский код для запроса %s.\n", query.Name))
	userContent.WriteString("// Вы можете свободно редактировать этот файл - он не будет перезаписан при регенерации.\n\n")
	userContent.WriteString("import (\n")
	userContent.WriteString("\t\"context\"\n")
	userContent.WriteString("\t\"fmt\"\n")
	userContent.WriteString(")\n\n")
	// Импорты domain и cache не добавляются автоматически, так как они могут быть неиспользованы
	// Пользователь добавит их при необходимости

	queryName := fmt.Sprintf("%sQuery", query.Name)
	handlerName := fmt.Sprintf("%sHandler", query.Name)
	responseName := fmt.Sprintf("%sResponse", query.Name)

	// Функция построения cache key (если cacheable)
	if query.Cacheable {
		cacheKeyFuncName := fmt.Sprintf("build%sCacheKey", query.Name)
		userContent.WriteString(fmt.Sprintf("// %s строит cache key для запроса %s\n", cacheKeyFuncName, query.Name))
		userContent.WriteString(fmt.Sprintf("func %s(q %s) string {\n", cacheKeyFuncName, queryName))
		userContent.WriteString("\t// TODO: Customize cache key based on query parameters\n")
		userContent.WriteString(fmt.Sprintf("\t// Example: return fmt.Sprintf(\"%s:%%s\", q.ID)\n", g.converter.ToSnakeCase(query.Name)))
		userContent.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(\"%s:%%v\", q)\n", g.converter.ToSnakeCase(query.Name)))
		userContent.WriteString("}\n\n")
	}

	// Функция загрузки данных
	loadDataFuncName := fmt.Sprintf("load%sData", query.Name)
	userContent.WriteString(fmt.Sprintf("// %s загружает данные для запроса %s\n", loadDataFuncName, query.Name))
	userContent.WriteString(fmt.Sprintf("// Реализуйте загрузку данных из репозитория или read model здесь\n"))
	userContent.WriteString(fmt.Sprintf("func %s(ctx context.Context, h *%s, q %s) (%s, error) {\n",
		loadDataFuncName, handlerName, queryName, responseName))
	userContent.WriteString("\t// TODO: Load data from repository or read model\n")
	userContent.WriteString("\t// Example:\n")
	userContent.WriteString("\t// item, err := h.itemRepo.FindByID(ctx, q.ID)\n")
	userContent.WriteString("\t// if err != nil {\n")
	userContent.WriteString("\t//     return nil, err\n")
	userContent.WriteString("\t// }\n")
	userContent.WriteString("\t// return GetItemResponse{\n")
	userContent.WriteString("\t//     ID: item.ID(),\n")
	userContent.WriteString("\t//     Name: item.Name(),\n")
	userContent.WriteString("\t// }, nil\n")
	userContent.WriteString(fmt.Sprintf("\treturn %s{}, fmt.Errorf(\"not implemented\")\n", responseName))
	userContent.WriteString("}\n")

	userPath := fmt.Sprintf("application/query/%s.go", g.converter.ToSnakeCase(query.Name))
	return g.writer.WriteFile(userPath, userContent.String())
}

// inferAggregateFromQueryName определяет имя агрегата из имени query
// Убирает префиксы "List", "Get", "Find", "Search" и обрабатывает множественное число
func inferAggregateFromQueryName(queryName string) string {
	// Список известных префиксов для удаления
	prefixes := []string{"List", "Get", "Find", "Search", "Fetch", "Retrieve", "Query"}

	for _, prefix := range prefixes {
		if strings.HasPrefix(queryName, prefix) {
			remaining := queryName[len(prefix):]
			if remaining == "" {
				return ""
			}

			// Обработка множественного числа: Items -> Item, Users -> User
			if len(remaining) > 1 && strings.HasSuffix(remaining, "s") {
				return remaining[:len(remaining)-1]
			}

			return remaining
		}
	}

	// Если префикс не найден, возвращаем имя как есть (с обработкой множественного числа)
	if len(queryName) > 1 && strings.HasSuffix(queryName, "s") {
		return queryName[:len(queryName)-1]
	}

	return queryName
}

// findAggregateByName ищет агрегат в списке по имени без учета регистра
// Возвращает указатель на найденный агрегат или nil, если не найден
func findAggregateByName(aggregates []AggregateSpec, name string) *AggregateSpec {
	for i := range aggregates {
		if strings.EqualFold(aggregates[i].Name, name) {
			return &aggregates[i]
		}
	}
	return nil
}
