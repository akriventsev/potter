package codegen

import (
	"fmt"
	"strings"
)

// ApplicationGenerator генератор application слоя
type ApplicationGenerator struct {
	*BaseGenerator
}

// NewApplicationGenerator создает новый генератор application слоя
func NewApplicationGenerator(outputDir string) *ApplicationGenerator {
	return &ApplicationGenerator{
		BaseGenerator: NewBaseGenerator("application", outputDir),
	}
}

// Generate генерирует application слой
func (g *ApplicationGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateCommands(spec, config); err != nil {
		return fmt.Errorf("failed to generate commands: %w", err)
	}

	if err := g.generateQueries(spec, config); err != nil {
		return fmt.Errorf("failed to generate queries: %w", err)
	}

	return nil
}

// generateCommands генерирует команды и handlers
func (g *ApplicationGenerator) generateCommands(spec *ParsedSpec, config *GeneratorConfig) error {
	for _, cmd := range spec.Commands {
		if err := g.generateCommand(cmd, spec, config); err != nil {
			return fmt.Errorf("failed to generate command %s: %w", cmd.Name, err)
		}
	}
	return nil
}

// generateCommand генерирует команду и handler
func (g *ApplicationGenerator) generateCommand(cmd CommandSpec, _ *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package command\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\n")
	if config != nil && config.ModulePath != "" {
		content.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	} else {
		content.WriteString("\t\"domain\"\n")
	}
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/events\"\n", baseImportPath))
	// Импорты invoke и time добавляются только если они используются в закомментированном коде
	// Они будут добавлены пользователем при раскомментировании кода сохранения и публикации событий
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	// Генерация команды
	cmdName := fmt.Sprintf("%sCommand", cmd.Name)
	content.WriteString(fmt.Sprintf("// %s команда\n", cmdName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", cmdName))

	// Поля из request типа (упрощенно - в реальности нужно парсить proto message)
	content.WriteString("\t// Add fields from request message\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (c %s) CommandName() string {\n", cmdName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(cmd.Name)))
	content.WriteString("}\n\n")

	// Генерация handler
	handlerName := fmt.Sprintf("%sHandler", cmd.Name)
	content.WriteString(fmt.Sprintf("// %s обработчик команды\n", handlerName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", handlerName))

	// Находим репозиторий для агрегата
	repoName := fmt.Sprintf("%sRepository", cmd.Aggregate)
	repoVarName := strings.ToLower(cmd.Aggregate) + "Repo"
	content.WriteString(fmt.Sprintf("\t%s domain.%s\n", repoVarName, repoName))
	content.WriteString("\teventPublisher events.EventPublisher\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("// New%s создает новый обработчик\n", handlerName))
	content.WriteString(fmt.Sprintf("func New%s(%s domain.%s, eventPublisher events.EventPublisher) *%s {\n",
		handlerName, repoVarName, repoName, handlerName))
	content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
	content.WriteString(fmt.Sprintf("\t\t%s: %s,\n", repoVarName, repoVarName))
	content.WriteString("\t\teventPublisher: eventPublisher,\n")
	content.WriteString("\t}\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) Handle(ctx context.Context, cmd transport.Command) error {\n", handlerName))
	content.WriteString(fmt.Sprintf("\t_, ok := cmd.(%s)\n", cmdName))
	content.WriteString("\tif !ok {\n")
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"invalid command type: %%T\", cmd)\n"))
	content.WriteString("\t}\n\n")
	content.WriteString(fmt.Sprintf("\t// Переменная команды будет доступна после раскомментирования кода ниже\n"))
	content.WriteString(fmt.Sprintf("\t// %s := cmd.(%s)\n", strings.ToLower(cmd.Name), cmdName))
	content.WriteString("\n")

	content.WriteString("// USER CODE BEGIN: Validation\n")
	content.WriteString("// Add validation logic here\n")
	content.WriteString("// USER CODE END: Validation\n\n")

	content.WriteString("// USER CODE BEGIN: BusinessLogic\n")
	content.WriteString("// TODO: Implement business logic here\n")
	content.WriteString(fmt.Sprintf("// REQUIRED: Create the aggregate variable '%s' before the code below:\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("// %s := domain.New%s(...)\n",
		strings.ToLower(cmd.Aggregate), cmd.Aggregate))
	content.WriteString(fmt.Sprintf("// Example: %s := domain.New%s(%s.Name, %s.Description, %s.Quantity)\n",
		strings.ToLower(cmd.Aggregate), cmd.Aggregate,
		strings.ToLower(cmd.Name), strings.ToLower(cmd.Name), strings.ToLower(cmd.Name)))
	content.WriteString("// USER CODE END: BusinessLogic\n\n")

	// Добавляем комментарий о необходимости раскомментировать код ниже
	content.WriteString(fmt.Sprintf("\t// ВАЖНО: Раскомментируйте код ниже после создания переменной '%s' в секции USER CODE выше\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("\t// Пример: %s := domain.New%s(...)\n\n", strings.ToLower(cmd.Aggregate), cmd.Aggregate))

	// Закомментируем код сохранения и публикации событий
	content.WriteString(fmt.Sprintf("\t/*\n"))
	content.WriteString(fmt.Sprintf("\t// Сохранение %s\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("\tif err := h.%s.Save(ctx, %s); err != nil {\n",
		repoVarName, strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to save %s: %%w\", err)\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\t}\n\n")

	content.WriteString("\t// Извлекаем correlation ID из контекста\n")
	content.WriteString("\tcorrelationID := invoke.ExtractCorrelationID(ctx)\n")
	content.WriteString("\tcausationID := invoke.ExtractCausationID(ctx)\n\n")

	content.WriteString("\t// Публикация событий с correlation ID\n")
	content.WriteString(fmt.Sprintf("\tfor _, event := range %s.Events() {\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\t\tif correlationID != \"\" {\n")
	content.WriteString("\t\t\tevent.Metadata().Set(\"correlation_id\", correlationID)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif causationID != \"\" {\n")
	content.WriteString("\t\t\tevent.Metadata().Set(\"causation_id\", causationID)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif err := h.eventPublisher.Publish(ctx, event); err != nil {\n")
	content.WriteString("\t\t\treturn fmt.Errorf(\"failed to publish event: %w\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}\n")
	content.WriteString(fmt.Sprintf("\t%s.ClearEvents()\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\t*/\n\n")
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) CommandName() string {\n", handlerName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(cmd.Name)))
	content.WriteString("}\n")

	path := fmt.Sprintf("application/command/%s.go", g.converter.ToSnakeCase(cmd.Name))
	return g.writer.WriteFile(path, content.String())
}

// generateQueries генерирует запросы и handlers
func (g *ApplicationGenerator) generateQueries(spec *ParsedSpec, config *GeneratorConfig) error {
	for _, query := range spec.Queries {
		if err := g.generateQuery(query, spec, config); err != nil {
			return fmt.Errorf("failed to generate query %s: %w", query.Name, err)
		}
	}
	return nil
}

// generateQuery генерирует запрос, response и handler
func (g *ApplicationGenerator) generateQuery(query QuerySpec, spec *ParsedSpec, config *GeneratorConfig) error {
	if config == nil {
		config = &GeneratorConfig{}
	}
	var content strings.Builder

	// Определяем, используется ли domain репозиторий
	hasReadModel := query.ReadModel != ""
	var usesDomain bool
	var foundAggregate *AggregateSpec
	if !hasReadModel {
		aggregateName := inferAggregateFromQueryName(query.Name)
		if aggregateName != "" {
			// Ищем агрегат в спецификации - только если найден, используем domain
			foundAggregate = findAggregateByName(spec.Aggregates, aggregateName)
			usesDomain = foundAggregate != nil
		}
	}

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package query\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	// Импорт time добавляется только если query cacheable
	if query.Cacheable {
		content.WriteString("\t\"time\"\n")
	}
	content.WriteString("\n")
	if usesDomain {
		content.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	}
	if query.Cacheable {
		content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/cache\"\n", config.ModulePath))
	}
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	// Генерация запроса
	queryName := fmt.Sprintf("%sQuery", query.Name)
	content.WriteString(fmt.Sprintf("// %s запрос\n", queryName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", queryName))
	content.WriteString("\t// Add fields from request message\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (q %s) QueryName() string {\n", queryName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(query.Name)))
	content.WriteString("}\n\n")

	// Генерация response
	responseName := fmt.Sprintf("%sResponse", query.Name)
	content.WriteString(fmt.Sprintf("// %s ответ на запрос\n", responseName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", responseName))
	content.WriteString("\t// Add fields from response message\n")
	content.WriteString("}\n\n")

	// Генерация handler
	handlerName := fmt.Sprintf("%sHandler", query.Name)
	content.WriteString(fmt.Sprintf("// %s обработчик запроса\n", handlerName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", handlerName))

	// Определяем какой репозиторий использовать
	if hasReadModel {
		// Query использует read model - НЕ добавляем поле репозитория агрегата
		content.WriteString(fmt.Sprintf("\t// This query uses read model: %s\n", query.ReadModel))
		content.WriteString("\t// TODO: Add read-model repository field here if needed\n")
	} else {
		// Query НЕ использует read model - определяем агрегат из имени query
		if foundAggregate != nil {
			// Агрегат найден в спецификации - добавляем поле репозитория
			repoName := fmt.Sprintf("%sRepository", foundAggregate.Name)
			repoVarName := strings.ToLower(foundAggregate.Name) + "Repo"
			content.WriteString(fmt.Sprintf("\t%s domain.%s\n", repoVarName, repoName))
		} else {
			// Агрегат не найден в спецификации - добавляем TODO комментарий
			content.WriteString("\t// TODO: Add repository field here based on your query data source\n")
			aggregateName := inferAggregateFromQueryName(query.Name)
			if aggregateName != "" {
				content.WriteString(fmt.Sprintf("\t// Inferred aggregate name '%s' was not found in spec.Aggregates\n", aggregateName))
			} else {
				content.WriteString("\t// Cannot automatically determine aggregate from query name\n")
			}
		}
	}

	if query.Cacheable {
		content.WriteString("\tcache cache.CacheService\n")
	}
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("// New%s создает новый обработчик\n", handlerName))

	// Генерируем конструктор в зависимости от наличия read_model и агрегата
	if hasReadModel {
		// Query имеет read_model - параметры: только cache (если cacheable)
		content.WriteString(fmt.Sprintf("func New%s(", handlerName))
		if query.Cacheable {
			content.WriteString("cache cache.CacheService")
		}
		content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
		content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
		if query.Cacheable {
			content.WriteString("\t\tcache: cache,\n")
		}
		content.WriteString("\t}\n")
		content.WriteString("}\n\n")
	} else {
		// Query НЕ имеет read_model - определяем агрегат
		if foundAggregate != nil {
			// Агрегат найден в спецификации - добавляем параметр репозитория
			repoName := fmt.Sprintf("%sRepository", foundAggregate.Name)
			repoVarName := strings.ToLower(foundAggregate.Name) + "Repo"

			content.WriteString(fmt.Sprintf("func New%s(%s domain.%s", handlerName, repoVarName, repoName))
			if query.Cacheable {
				content.WriteString(", cache cache.CacheService")
			}
			content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
			content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
			content.WriteString(fmt.Sprintf("\t\t%s: %s,\n", repoVarName, repoVarName))
			if query.Cacheable {
				content.WriteString("\t\tcache: cache,\n")
			}
			content.WriteString("\t}\n")
			content.WriteString("}\n\n")
		} else {
			// Агрегат не найден в спецификации - только cache (если cacheable) и TODO комментарий
			content.WriteString(fmt.Sprintf("// TODO: Add repository parameter(s) to constructor based on your query data source\n"))
			aggregateName := inferAggregateFromQueryName(query.Name)
			if aggregateName != "" {
				content.WriteString(fmt.Sprintf("// Inferred aggregate name '%s' was not found in spec.Aggregates\n", aggregateName))
			}
			content.WriteString(fmt.Sprintf("func New%s(", handlerName))
			if query.Cacheable {
				content.WriteString("cache cache.CacheService")
			}
			content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
			content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
			if query.Cacheable {
				content.WriteString("\t\tcache: cache,\n")
			}
			content.WriteString("\t}\n")
			content.WriteString("}\n\n")
		}
	}

	content.WriteString(fmt.Sprintf("func (h *%s) Handle(ctx context.Context, q transport.Query) (interface{}, error) {\n", handlerName))
	content.WriteString(fmt.Sprintf("\t_, ok := q.(%s)\n", queryName))
	content.WriteString("\tif !ok {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"invalid query type: %T\", q)\n")
	content.WriteString("\t}\n\n")
	content.WriteString(fmt.Sprintf("\t// Переменная запроса будет доступна после раскомментирования кода ниже\n"))
	content.WriteString(fmt.Sprintf("\t// %s := q.(%s)\n", strings.ToLower(query.Name), queryName))
	content.WriteString("\n")

	if query.Cacheable {
		content.WriteString("\t// Попытка получить из кеша\n")
		content.WriteString("\t// TODO: Customize cache key based on query parameters\n")
		content.WriteString("\t// Раскомментируйте переменную запроса выше и используйте её для формирования cache key:\n")
		content.WriteString(fmt.Sprintf("\t// cacheKey := fmt.Sprintf(\"%s:%%v\", %s)\n",
			g.converter.ToSnakeCase(query.Name), strings.ToLower(query.Name)))
		content.WriteString(fmt.Sprintf("\t// Example with specific field: cacheKey := fmt.Sprintf(\"%s:%%s\", %s.ID)\n",
			g.converter.ToSnakeCase(query.Name), strings.ToLower(query.Name)))
		content.WriteString("\t// Временный cache key для примера (замените на реальный после раскомментирования переменной запроса):\n")
		content.WriteString(fmt.Sprintf("\tcacheKey := fmt.Sprintf(\"%s:placeholder\")\n", g.converter.ToSnakeCase(query.Name)))
		content.WriteString(fmt.Sprintf("\tvar response %s\n", responseName))
		content.WriteString("\texists, err := h.cache.Get(ctx, cacheKey, &response)\n")
		content.WriteString("\tif err == nil && exists {\n")
		content.WriteString("\t\treturn response, nil\n")
		content.WriteString("\t}\n\n")
	}

	content.WriteString("// USER CODE BEGIN: LoadData\n")
	content.WriteString("// Load data from repository\n")
	content.WriteString("// USER CODE END: LoadData\n\n")

	content.WriteString("\t// Маппинг в response\n")
	if query.Cacheable {
		// Если cacheable, переменная response уже объявлена выше
		content.WriteString(fmt.Sprintf("\tresponse = %s{\n", responseName))
	} else {
		// Если не cacheable, нужно объявить переменную
		content.WriteString(fmt.Sprintf("\tresponse := %s{\n", responseName))
	}
	content.WriteString("\t\t// Map fields here\n")
	content.WriteString("\t}\n\n")

	if query.Cacheable {
		content.WriteString(fmt.Sprintf("\t// Сохранить в кеш с TTL %d секунд\n", query.CacheTTLSeconds))
		content.WriteString(fmt.Sprintf("\tif err := h.cache.Set(ctx, cacheKey, response, %d*time.Second); err != nil {\n",
			query.CacheTTLSeconds))
		content.WriteString("\t\t// Логируем ошибку, но не прерываем выполнение\n")
		content.WriteString("\t\t_ = err\n")
		content.WriteString("\t}\n\n")
	}

	content.WriteString("\treturn response, nil\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) QueryName() string {\n", handlerName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(query.Name)))
	content.WriteString("}\n")

	path := fmt.Sprintf("application/query/%s.go", g.converter.ToSnakeCase(query.Name))
	return g.writer.WriteFile(path, content.String())
}

// inferAggregateFromQueryName определяет имя агрегата из имени query
// Убирает префиксы "List", "Get", "Find", "Search" и обрабатывает множественное число
func inferAggregateFromQueryName(queryName string) string {
	// Список известных префиксов для удаления
	prefixes := []string{"List", "Get", "Find", "Search", "Fetch", "Retrieve", "Query"}

	for _, prefix := range prefixes {
		if strings.HasPrefix(queryName, prefix) {
			remaining := queryName[len(prefix):]
			if remaining == "" {
				return ""
			}

			// Обработка множественного числа: Items -> Item, Users -> User
			if len(remaining) > 1 && strings.HasSuffix(remaining, "s") {
				return remaining[:len(remaining)-1]
			}

			return remaining
		}
	}

	// Если префикс не найден, возвращаем имя как есть (с обработкой множественного числа)
	if len(queryName) > 1 && strings.HasSuffix(queryName, "s") {
		return queryName[:len(queryName)-1]
	}

	return queryName
}

// findAggregateByName ищет агрегат в списке по имени без учета регистра
// Возвращает указатель на найденный агрегат или nil, если не найден
func findAggregateByName(aggregates []AggregateSpec, name string) *AggregateSpec {
	for i := range aggregates {
		if strings.EqualFold(aggregates[i].Name, name) {
			return &aggregates[i]
		}
	}
	return nil
}
