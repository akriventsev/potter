package codegen

import (
	"fmt"
	"strings"
)

// ApplicationGenerator генератор application слоя
type ApplicationGenerator struct {
	*BaseGenerator
}

// NewApplicationGenerator создает новый генератор application слоя
func NewApplicationGenerator(outputDir string) *ApplicationGenerator {
	return &ApplicationGenerator{
		BaseGenerator: NewBaseGenerator("application", outputDir),
	}
}

// Generate генерирует application слой
func (g *ApplicationGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateCommands(spec, config); err != nil {
		return fmt.Errorf("failed to generate commands: %w", err)
	}

	if err := g.generateQueries(spec, config); err != nil {
		return fmt.Errorf("failed to generate queries: %w", err)
	}

	return nil
}

// generateCommands генерирует команды и handlers
func (g *ApplicationGenerator) generateCommands(spec *ParsedSpec, config *GeneratorConfig) error {
	for _, cmd := range spec.Commands {
		if err := g.generateCommand(cmd, spec, config); err != nil {
			return fmt.Errorf("failed to generate command %s: %w", cmd.Name, err)
		}
	}
	return nil
}

// generateCommand генерирует команду и handler
func (g *ApplicationGenerator) generateCommand(cmd CommandSpec, _ *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package command\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\n")
	if config != nil && config.ModulePath != "" {
		content.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	} else {
		content.WriteString("\t\"domain\"\n")
	}
	content.WriteString("\t\"github.com/akriventsev/potter/framework/events\"\n")
	content.WriteString("\t\"github.com/akriventsev/potter/framework/invoke\"\n")
	content.WriteString("\t\"github.com/akriventsev/potter/framework/transport\"\n")
	content.WriteString(")\n\n")

	// Генерация команды
	cmdName := fmt.Sprintf("%sCommand", cmd.Name)
	content.WriteString(fmt.Sprintf("// %s команда\n", cmdName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", cmdName))

	// Поля из request типа (упрощенно - в реальности нужно парсить proto message)
	content.WriteString("\t// Add fields from request message\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (c %s) CommandName() string {\n", cmdName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(cmd.Name)))
	content.WriteString("}\n\n")

	// Генерация handler
	handlerName := fmt.Sprintf("%sHandler", cmd.Name)
	content.WriteString(fmt.Sprintf("// %s обработчик команды\n", handlerName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", handlerName))

	// Находим репозиторий для агрегата
	repoName := fmt.Sprintf("%sRepository", cmd.Aggregate)
	repoVarName := strings.ToLower(cmd.Aggregate) + "Repo"
	content.WriteString(fmt.Sprintf("\t%s domain.%s\n", repoVarName, repoName))
	content.WriteString("\teventPublisher events.EventPublisher\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("// New%s создает новый обработчик\n", handlerName))
	content.WriteString(fmt.Sprintf("func New%s(%s domain.%s, eventPublisher events.EventPublisher) *%s {\n",
		handlerName, repoVarName, repoName, handlerName))
	content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
	content.WriteString(fmt.Sprintf("\t\t%s: %s,\n", repoVarName, repoVarName))
	content.WriteString("\t\teventPublisher: eventPublisher,\n")
	content.WriteString("\t}\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) Handle(ctx context.Context, cmd transport.Command) error {\n", handlerName))
	content.WriteString(fmt.Sprintf("\t%s, ok := cmd.(%s)\n", strings.ToLower(cmd.Name), cmdName))
	content.WriteString("\tif !ok {\n")
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"invalid command type: %%T\", cmd)\n"))
	content.WriteString("\t}\n\n")

	content.WriteString("// USER CODE BEGIN: Validation\n")
	content.WriteString("// Add validation logic here\n")
	content.WriteString("// USER CODE END: Validation\n\n")

	content.WriteString("// USER CODE BEGIN: BusinessLogic\n")
	content.WriteString("// Implement business logic here\n")
	content.WriteString(fmt.Sprintf("// Example: %s := domain.New%s(...)\n",
		strings.ToLower(cmd.Aggregate), cmd.Aggregate))
	content.WriteString("// USER CODE END: BusinessLogic\n\n")

	content.WriteString(fmt.Sprintf("\t// Сохранение %s\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("\tif err := h.%s.Save(ctx, %s); err != nil {\n",
		repoVarName, strings.ToLower(cmd.Aggregate)))
	content.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to save %s: %%w\", err)\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\t}\n\n")

	content.WriteString("\t// Извлекаем correlation ID из контекста\n")
	content.WriteString("\tcorrelationID := invoke.ExtractCorrelationID(ctx)\n")
	content.WriteString("\tcausationID := invoke.ExtractCausationID(ctx)\n\n")

	content.WriteString("\t// Публикация событий с correlation ID\n")
	content.WriteString(fmt.Sprintf("\tfor _, event := range %s.Events() {\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\t\tif correlationID != \"\" {\n")
	content.WriteString("\t\t\tevent.Metadata().Set(\"correlation_id\", correlationID)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif causationID != \"\" {\n")
	content.WriteString("\t\t\tevent.Metadata().Set(\"causation_id\", causationID)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tif err := h.eventPublisher.Publish(ctx, event); err != nil {\n")
	content.WriteString("\t\t\treturn fmt.Errorf(\"failed to publish event: %w\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}\n")
	content.WriteString(fmt.Sprintf("\t%s.ClearEvents()\n\n", strings.ToLower(cmd.Aggregate)))
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) CommandName() string {\n", handlerName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(cmd.Name)))
	content.WriteString("}\n")

	path := fmt.Sprintf("application/command/%s.go", g.converter.ToSnakeCase(cmd.Name))
	return g.writer.WriteFile(path, content.String())
}

// generateQueries генерирует запросы и handlers
func (g *ApplicationGenerator) generateQueries(spec *ParsedSpec, config *GeneratorConfig) error {
	for _, query := range spec.Queries {
		if err := g.generateQuery(query, spec, config); err != nil {
			return fmt.Errorf("failed to generate query %s: %w", query.Name, err)
		}
	}
	return nil
}

// generateQuery генерирует запрос, response и handler
func (g *ApplicationGenerator) generateQuery(query QuerySpec, spec *ParsedSpec, config *GeneratorConfig) error {
	if config == nil {
		config = &GeneratorConfig{}
	}
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package query\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"time\"\n")
	content.WriteString("\n")
	content.WriteString(fmt.Sprintf("\t\"%s/domain\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/cache\"\n", config.ModulePath))
	content.WriteString("\t\"github.com/akriventsev/potter/framework/transport\"\n")
	content.WriteString(")\n\n")

	// Генерация запроса
	queryName := fmt.Sprintf("%sQuery", query.Name)
	content.WriteString(fmt.Sprintf("// %s запрос\n", queryName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", queryName))
	content.WriteString("\t// Add fields from request message\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (q %s) QueryName() string {\n", queryName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(query.Name)))
	content.WriteString("}\n\n")

	// Генерация response
	responseName := fmt.Sprintf("%sResponse", query.Name)
	content.WriteString(fmt.Sprintf("// %s ответ на запрос\n", responseName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", responseName))
	content.WriteString("\t// Add fields from response message\n")
	content.WriteString("}\n\n")

	// Генерация handler
	handlerName := fmt.Sprintf("%sHandler", query.Name)
	content.WriteString(fmt.Sprintf("// %s обработчик запроса\n", handlerName))
	content.WriteString(fmt.Sprintf("type %s struct {\n", handlerName))

	// Определяем какой репозиторий использовать
	// Если query использует read model, добавляем комментарий о read-model repository
	// Если невозможно однозначно определить агрегат, не создаем поле автоматически,
	// а добавляем комментарий с инструкциями
	hasReadModel := query.ReadModel != ""
	hasAggregates := len(spec.Aggregates) > 0
	
	if hasReadModel {
		// Query использует read model - добавляем комментарий о read-model repository
		content.WriteString("\t// TODO: Add read-model repository field here\n")
		content.WriteString(fmt.Sprintf("\t// This query uses read model: %s\n", query.ReadModel))
		content.WriteString("\t// Example: readModelRepo ReadModelRepository\n")
		content.WriteString("\t// Example: readModelRepo domain.ReadModelRepository\n")
	} else if !hasAggregates {
		// Если нет агрегатов, добавляем комментарий с инструкциями
		content.WriteString("\t// TODO: Add repository field here based on your query data source\n")
		content.WriteString("\t// If query reads aggregate data, add aggregate repository:\n")
		content.WriteString("\t//   Example: repo domain.SomeRepository\n")
		content.WriteString("\t// If query uses read model, add read-model repository:\n")
		content.WriteString("\t//   Example: readModelRepo ReadModelRepository\n")
		content.WriteString("\t//   Example: readModelRepo domain.ReadModelRepository\n")
	} else {
		// Есть агрегаты, но нет явной связи query с агрегатом
		// Не создаем поле автоматически, а добавляем комментарий с инструкциями
		content.WriteString("\t// TODO: Add repository field here\n")
		content.WriteString("\t// Cannot automatically determine which repository to use for this query.\n")
		content.WriteString("\t// If query reads aggregate data, add the appropriate aggregate repository:\n")
		for _, agg := range spec.Aggregates {
			content.WriteString(fmt.Sprintf("\t//   Example: %sRepo domain.%sRepository\n",
				strings.ToLower(agg.Name), agg.Name))
		}
		content.WriteString("\t// If query uses read model, add read-model repository:\n")
		content.WriteString("\t//   Example: readModelRepo ReadModelRepository\n")
		content.WriteString("\t//   Example: readModelRepo domain.ReadModelRepository\n")
	}
	
	if query.Cacheable {
		content.WriteString("\tcache cache.CacheService\n")
	}
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("// New%s создает новый обработчик\n", handlerName))
	
	// В конструкторе также не создаем параметры репозитория автоматически,
	// если невозможно однозначно определить
	if hasReadModel || !hasAggregates {
		// Для read-model или когда нет агрегатов - не добавляем параметры репозитория
		content.WriteString(fmt.Sprintf("func New%s(", handlerName))
		if query.Cacheable {
			content.WriteString("cache cache.CacheService")
		}
		content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
		content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
		if query.Cacheable {
			content.WriteString("\t\tcache: cache,\n")
		}
		content.WriteString("\t}\n")
		content.WriteString("}\n\n")
	} else {
		// Есть агрегаты, но нет явной связи - не добавляем параметры автоматически
		// Добавляем комментарий с инструкциями
		content.WriteString(fmt.Sprintf("// TODO: Add repository parameter(s) to constructor based on your query data source\n"))
		content.WriteString(fmt.Sprintf("func New%s(", handlerName))
		if query.Cacheable {
			content.WriteString("cache cache.CacheService")
		}
		content.WriteString(fmt.Sprintf(") *%s {\n", handlerName))
		content.WriteString(fmt.Sprintf("\treturn &%s{\n", handlerName))
		if query.Cacheable {
			content.WriteString("\t\tcache: cache,\n")
		}
		content.WriteString("\t}\n")
		content.WriteString("}\n\n")
	}

	content.WriteString(fmt.Sprintf("func (h *%s) Handle(ctx context.Context, q transport.Query) (interface{}, error) {\n", handlerName))
	content.WriteString(fmt.Sprintf("\t%s, ok := q.(%s)\n", strings.ToLower(query.Name), queryName))
	content.WriteString("\tif !ok {\n")
	content.WriteString("\t\treturn nil, fmt.Errorf(\"invalid query type: %T\", q)\n")
	content.WriteString("\t}\n\n")

	if query.Cacheable {
		content.WriteString("\t// Попытка получить из кеша\n")
		content.WriteString(fmt.Sprintf("\tcacheKey := fmt.Sprintf(\"%s:%%s\", %s.ID)\n",
			g.converter.ToSnakeCase(query.Name), strings.ToLower(query.Name)))
		content.WriteString(fmt.Sprintf("\tvar response %s\n", responseName))
		content.WriteString("\texists, err := h.cache.Get(ctx, cacheKey, &response)\n")
		content.WriteString("\tif err == nil && exists {\n")
		content.WriteString("\t\treturn response, nil\n")
		content.WriteString("\t}\n\n")
	}

	content.WriteString("// USER CODE BEGIN: LoadData\n")
	content.WriteString("// Load data from repository\n")
	content.WriteString("// USER CODE END: LoadData\n\n")

	content.WriteString("\t// Маппинг в response\n")
	content.WriteString(fmt.Sprintf("\tresponse := %s{\n", responseName))
	content.WriteString("\t\t// Map fields here\n")
	content.WriteString("\t}\n\n")

	if query.Cacheable {
		content.WriteString(fmt.Sprintf("\t// Сохранить в кеш с TTL %d секунд\n", query.CacheTTLSeconds))
		content.WriteString(fmt.Sprintf("\tif err := h.cache.Set(ctx, cacheKey, response, %d*time.Second); err != nil {\n",
			query.CacheTTLSeconds))
		content.WriteString("\t\t// Логируем ошибку, но не прерываем выполнение\n")
		content.WriteString("\t\t_ = err\n")
		content.WriteString("\t}\n\n")
	}

	content.WriteString("\treturn response, nil\n")
	content.WriteString("}\n\n")

	content.WriteString(fmt.Sprintf("func (h *%s) QueryName() string {\n", handlerName))
	content.WriteString(fmt.Sprintf("\treturn %q\n", g.converter.ToSnakeCase(query.Name)))
	content.WriteString("}\n")

	path := fmt.Sprintf("application/query/%s.go", g.converter.ToSnakeCase(query.Name))
	return g.writer.WriteFile(path, content.String())
}
