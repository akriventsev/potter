package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Generator интерфейс для генераторов кода
type Generator interface {
	Generate(spec *ParsedSpec, config *GeneratorConfig) error
	Name() string
	OutputPath() string
}

// GeneratorConfig конфигурация генератора
type GeneratorConfig struct {
	ModulePath       string
	OutputDir        string
	PackageName      string
	Overwrite        bool
	PreserveUserCode bool
	Templates        map[string]string
	PotterImportPath string // Путь импорта Potter framework (например, "github.com/akriventsev/potter")
}

// FileWriter утилита для записи файлов
type FileWriter struct {
	outputDir string
}

// NewFileWriter создает новый FileWriter
func NewFileWriter(outputDir string) *FileWriter {
	return &FileWriter{outputDir: outputDir}
}

// WriteFile записывает файл с созданием директорий
func (w *FileWriter) WriteFile(path, content string) error {
	fullPath := filepath.Join(w.outputDir, path)
	if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	return os.WriteFile(fullPath, []byte(content), 0644)
}

// FileExists проверяет существование файла
func (w *FileWriter) FileExists(path string) bool {
	fullPath := filepath.Join(w.outputDir, path)
	_, err := os.Stat(fullPath)
	return err == nil
}

// BackupFile создает backup файла
func (w *FileWriter) BackupFile(path string) error {
	fullPath := filepath.Join(w.outputDir, path)
	if !w.FileExists(path) {
		return nil
	}

	backupPath := fullPath + ".backup"
	data, err := os.ReadFile(fullPath)
	if err != nil {
		return fmt.Errorf("failed to read file for backup: %w", err)
	}

	return os.WriteFile(backupPath, data, 0644)
}

// NameConverter утилита для конвертации имен
type NameConverter struct{}

// ToSnakeCase конвертирует CamelCase в snake_case
func (nc *NameConverter) ToSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		if r >= 'A' && r <= 'Z' {
			result = append(result, r+32) // to lowercase
		} else {
			result = append(result, r)
		}
	}
	return strings.ToLower(string(result))
}

// ToCamelCase конвертирует snake_case в CamelCase
func (nc *NameConverter) ToCamelCase(s string) string {
	parts := strings.Split(s, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]) + part[1:])
		}
	}
	return result.String()
}

// ToPackageName конвертирует имя сервиса в имя пакета
func (nc *NameConverter) ToPackageName(s string) string {
	return strings.ToLower(s)
}

// ImportManager утилита для управления импортами
type ImportManager struct {
	imports map[string]string // alias -> path
}

// NewImportManager создает новый ImportManager
func NewImportManager() *ImportManager {
	return &ImportManager{
		imports: make(map[string]string),
	}
}

// AddImport добавляет импорт
func (im *ImportManager) AddImport(alias, path string) {
	im.imports[path] = alias
}

// GenerateImports генерирует блок импортов
func (im *ImportManager) GenerateImports() string {
	if len(im.imports) == 0 {
		return ""
	}

	var builder strings.Builder
	builder.WriteString("import (\n")
	for path, alias := range im.imports {
		if alias != "" && alias != filepath.Base(path) {
			builder.WriteString(fmt.Sprintf("\t%s %q\n", alias, path))
		} else {
			builder.WriteString(fmt.Sprintf("\t%q\n", path))
		}
	}
	builder.WriteString(")\n")
	return builder.String()
}

// OptimizeImports удаляет неиспользуемые импорты
func (im *ImportManager) OptimizeImports() {
	// Упрощенная реализация - в реальности нужно анализировать использование
}

// BaseGenerator базовая реализация генератора
type BaseGenerator struct {
	name      string
	outputDir string
	writer    *FileWriter
	converter *NameConverter
}

// NewBaseGenerator создает новый базовый генератор
func NewBaseGenerator(name, outputDir string) *BaseGenerator {
	return &BaseGenerator{
		name:      name,
		outputDir: outputDir,
		writer:    NewFileWriter(outputDir),
		converter: &NameConverter{},
	}
}

// Name возвращает имя генератора
func (g *BaseGenerator) Name() string {
	return g.name
}

// OutputPath возвращает путь для вывода
func (g *BaseGenerator) OutputPath() string {
	return g.outputDir
}

// ensureDir создает директорию если не существует
func (g *BaseGenerator) ensureDir(path string) error {
	fullPath := filepath.Join(g.outputDir, path)
	return os.MkdirAll(fullPath, 0755)
}

// formatCode форматирует код через gofmt
func (g *BaseGenerator) formatCode(code string) (string, error) {
	// В реальной реализации нужно вызвать gofmt
	// Здесь возвращаем как есть
	return code, nil
}

// addFileHeader генерирует заголовок файла
func (g *BaseGenerator) addFileHeader(packageName string) string {
	return fmt.Sprintf("// Code generated by potter-gen. DO NOT EDIT.\n\npackage %s\n\n", packageName)
}
