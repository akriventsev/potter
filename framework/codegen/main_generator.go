package codegen

import (
	"fmt"
	"strings"
)

// MainGenerator генератор main.go и вспомогательных файлов
type MainGenerator struct {
	*BaseGenerator
}

// NewMainGenerator создает новый генератор main
func NewMainGenerator(outputDir string) *MainGenerator {
	return &MainGenerator{
		BaseGenerator: NewBaseGenerator("main", outputDir),
	}
}

// Generate генерирует main.go и вспомогательные файлы
func (g *MainGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateMain(spec, config); err != nil {
		return fmt.Errorf("failed to generate main: %w", err)
	}

	if err := g.generateMakefile(spec, config); err != nil {
		return fmt.Errorf("failed to generate Makefile: %w", err)
	}

	if err := g.generateDockerCompose(spec, config); err != nil {
		return fmt.Errorf("failed to generate docker-compose: %w", err)
	}

	if err := g.generateEnvExample(spec, config); err != nil {
		return fmt.Errorf("failed to generate .env.example: %w", err)
	}

	if err := g.generateREADME(spec, config); err != nil {
		return fmt.Errorf("failed to generate README: %w", err)
	}

	if err := g.generateGoMod(spec, config); err != nil {
		return fmt.Errorf("failed to generate go.mod: %w", err)
	}

	return nil
}

// generateMain генерирует cmd/server/main.go
func (g *MainGenerator) generateMain(spec *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package main\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"log\"\n")
	content.WriteString("\t\"net/http\"\n")
	content.WriteString("\t\"os\"\n")
	content.WriteString("\t\"os/signal\"\n")
	content.WriteString("\t\"syscall\"\n")
	content.WriteString("\t\"time\"\n")
	content.WriteString("\n")
	content.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	content.WriteString("\t\"github.com/jackc/pgx/v5/pgxpool\"\n")
	content.WriteString("\t\"github.com/redis/go-redis/v9\"\n")
	content.WriteString("\t\"go.opentelemetry.io/otel/sdk/metric\"\n")
	content.WriteString(fmt.Sprintf("\t\"%s/application/command\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/application/query\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/config\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/cache\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/repository\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/presentation/rest\"\n", config.ModulePath))
	content.WriteString("\t\"potter/framework/adapters/events\"\n")
	content.WriteString("\t\"potter/framework/adapters/messagebus\"\n")
	content.WriteString("\t\"potter/framework/events\"\n")
	content.WriteString("\t\"potter/framework/metrics\"\n")
	content.WriteString("\t\"potter/framework/transport\"\n")
	content.WriteString(")\n\n")

	content.WriteString("func main() {\n")
	content.WriteString("\t// Загрузка конфигурации\n")
	content.WriteString("\tcfg := config.LoadConfig()\n\n")
	content.WriteString("\tctx, cancel := context.WithCancel(context.Background())\n")
	content.WriteString("\tdefer cancel()\n\n")
	content.WriteString("\t// Инициализация метрик\n")
	content.WriteString("\tvar metricsProvider *metric.MeterProvider\n")
	content.WriteString("\tif cfg.Metrics.Enabled {\n")
	content.WriteString("\t\tmetricsConfig := &metrics.MetricsConfig{\n")
	content.WriteString("\t\t\tExporterType:   \"prometheus\",\n")
	content.WriteString("\t\t\tPrometheusPort: cfg.Metrics.Port,\n")
	content.WriteString("\t\t\tSamplingRate:   1.0,\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tprovider, err := metrics.SetupMetrics(metricsConfig)\n")
	content.WriteString("\t\tif err != nil {\n")
	content.WriteString("\t\t\tlog.Fatalf(\"Failed to setup metrics: %v\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tmetricsProvider = provider\n")
	content.WriteString("\t\tdefer func() {\n")
	content.WriteString("\t\t\tif err := metrics.ShutdownMetrics(ctx, metricsProvider); err != nil {\n")
	content.WriteString("\t\t\t\tlog.Printf(\"Failed to shutdown metrics: %v\", err)\n")
	content.WriteString("\t\t\t}\n")
	content.WriteString("\t\t}()\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Создание PostgreSQL connection pool\n")
	content.WriteString("\tdb, err := pgxpool.New(ctx, cfg.Database.DSN)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to connect to database: %v\", err)\n")
	content.WriteString("\t}\n")
	content.WriteString("\tdefer db.Close()\n\n")
	content.WriteString("\t// Создание Redis client\n")
	content.WriteString("\tredisClient := redis.NewClient(&redis.Options{\n")
	content.WriteString("\t\tAddr:     cfg.Redis.Addr,\n")
	content.WriteString("\t\tPassword: cfg.Redis.Password,\n")
	content.WriteString("\t\tDB:       cfg.Redis.DB,\n")
	content.WriteString("\t})\n")
	content.WriteString("\tdefer redisClient.Close()\n\n")
	content.WriteString("\t// Проверка подключения к Redis\n")
	content.WriteString("\tif err := redisClient.Ping(ctx).Err(); err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to connect to Redis: %v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Создание NATS client\n")
	content.WriteString("\tnatsAdapter, err := messagebus.NewNATSAdapter(cfg.NATS.URL)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to create NATS adapter: %v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\tif err := natsAdapter.Start(ctx); err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to start NATS adapter: %v\", err)\n")
	content.WriteString("\t}\n")
	content.WriteString("\tdefer natsAdapter.Stop(ctx)\n\n")
	content.WriteString("\t// Создание сервисов\n")
	content.WriteString("\tcacheService := cache.NewRedisCacheService(redisClient)\n\n")

	// Создание репозиториев
	content.WriteString("\t// Создание репозиториев\n")
	for _, agg := range spec.Aggregates {
		repoName := fmt.Sprintf("%sRepo", strings.ToLower(agg.Name))
		content.WriteString(fmt.Sprintf("\t%s := repository.NewPostgres%sRepository(db, cacheService)\n",
			repoName, agg.Name))
	}
	content.WriteString("\n")

	// Создание EventPublisher
	content.WriteString("\t// Создание EventPublisher\n")
	content.WriteString("\teventConfig := events.NATSEventConfig{\n")
	content.WriteString("\t\tConn:          natsAdapter.Conn(),\n")
	content.WriteString("\t\tSubjectPrefix: \"events\",\n")
	content.WriteString("\t}\n")
	content.WriteString("\teventPublisher, err := events.NewNATSEventAdapter(eventConfig)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to create event publisher: %v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\tif err := eventPublisher.Start(ctx); err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to start event publisher: %v\", err)\n")
	content.WriteString("\t}\n")
	content.WriteString("\tdefer eventPublisher.Stop(ctx)\n\n")

	// Создание CommandBus и QueryBus
	content.WriteString("\t// Создание CommandBus и QueryBus\n")
	content.WriteString("\tcommandBus := transport.NewInMemoryCommandBus()\n")
	content.WriteString("\tqueryBus := transport.NewInMemoryQueryBus()\n\n")

	// Регистрация command handlers
	content.WriteString("\t// Регистрация command handlers\n")
	for _, cmd := range spec.Commands {
		handlerName := fmt.Sprintf("%sHandler", cmd.Name)
		aggName := strings.ToLower(cmd.Aggregate)
		content.WriteString(fmt.Sprintf("\t%s := command.New%sHandler(%sRepo, eventPublisher)\n",
			strings.ToLower(handlerName), cmd.Name, aggName))
		content.WriteString(fmt.Sprintf("\tif err := commandBus.Register(%s); err != nil {\n",
			strings.ToLower(handlerName)))
		content.WriteString(fmt.Sprintf("\t\tlog.Fatalf(\"Failed to register %s handler: %%v\", err)\n", cmd.Name))
		content.WriteString("\t}\n")
	}
	content.WriteString("\n")

	// Регистрация query handlers
	content.WriteString("\t// Регистрация query handlers\n")
	for _, query := range spec.Queries {
		handlerName := fmt.Sprintf("%sHandler", query.Name)
		// Для query определяем репозиторий (можно использовать первый доступный или создать общий)
		// Упрощенно: используем первый агрегат, если есть
		if len(spec.Aggregates) > 0 {
			firstAgg := spec.Aggregates[0]
			repoVarName := strings.ToLower(firstAgg.Name) + "Repo"
			if query.Cacheable {
				content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(%s, cacheService)\n",
					strings.ToLower(handlerName), query.Name, repoVarName))
			} else {
				content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(%s)\n",
					strings.ToLower(handlerName), query.Name, repoVarName))
			}
		} else {
			// Если нет агрегатов, query handler без репозитория
			if query.Cacheable {
				content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(nil, cacheService)\n",
					strings.ToLower(handlerName), query.Name))
			} else {
				content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(nil)\n",
					strings.ToLower(handlerName), query.Name))
			}
		}
		content.WriteString(fmt.Sprintf("\tif err := queryBus.Register(%s); err != nil {\n",
			strings.ToLower(handlerName)))
		content.WriteString(fmt.Sprintf("\t\tlog.Fatalf(\"Failed to register %s handler: %%v\", err)\n", query.Name))
		content.WriteString("\t}\n")
	}
	content.WriteString("\n")

	// Создание REST handler
	content.WriteString("\t// Создание REST handler\n")
	content.WriteString("\trestHandler := rest.NewHandler(commandBus, queryBus)\n\n")
	content.WriteString("\t// Настройка Gin router\n")
	content.WriteString("\trouter := gin.Default()\n")
	content.WriteString("\trestHandler.RegisterRoutes(router)\n\n")
	content.WriteString("\t// Запуск HTTP сервера\n")
	content.WriteString("\tsrv := &http.Server{\n")
	content.WriteString("\t\tAddr:    fmt.Sprintf(\":%%d\", cfg.Server.Port),\n")
	content.WriteString("\t\tHandler: router,\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\tgo func() {\n")
	content.WriteString("\t\tlog.Printf(\"Server starting on port %%d\", cfg.Server.Port)\n")
	content.WriteString("\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n")
	content.WriteString("\t\t\tlog.Fatalf(\"Failed to start server: %%v\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t}()\n\n")
	content.WriteString("\t// Graceful shutdown\n")
	content.WriteString("\tquit := make(chan os.Signal, 1)\n")
	content.WriteString("\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n")
	content.WriteString("\t<-quit\n\n")
	content.WriteString("\tlog.Println(\"Shutting down application...\")\n\n")
	content.WriteString("\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)\n")
	content.WriteString("\tdefer shutdownCancel()\n\n")
	content.WriteString("\tif err := srv.Shutdown(shutdownCtx); err != nil {\n")
	content.WriteString("\t\tlog.Printf(\"Error during server shutdown: %%v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\tlog.Println(\"Application stopped\")\n")
	content.WriteString("}\n")

	path := "cmd/server/main.go"
	return g.writer.WriteFile(path, content.String())
}

// generateMakefile генерирует Makefile
func (g *MainGenerator) generateMakefile(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `.PHONY: run build docker-up docker-down migrate test clean help

# Переменные
DATABASE_DSN ?= postgres://postgres:postgres@localhost:5432/db?sslmode=disable
REDIS_ADDR ?= localhost:6379
NATS_URL ?= nats://localhost:4222

# Запуск приложения
run:
	@echo "Running application..."
	@go run cmd/server/main.go

# Сборка бинарника
build:
	@echo "Building application..."
	@mkdir -p bin
	@go build -o bin/server cmd/server/main.go

# Запуск docker-compose
docker-up:
	@echo "Starting infrastructure services..."
	@docker-compose up -d

# Остановка docker-compose
docker-down:
	@echo "Stopping infrastructure services..."
	@docker-compose down

# Применение миграций
migrate:
	@echo "Waiting for PostgreSQL to be ready..."
	@until PGPASSWORD=postgres psql -h localhost -U postgres -d postgres -c '\q' 2>/dev/null; do sleep 1; done
	@echo "Creating database if it doesn't exist..."
	@PGPASSWORD=postgres psql -h localhost -U postgres -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = 'db'" | grep -q 1 || PGPASSWORD=postgres psql -h localhost -U postgres -d postgres -c 'CREATE DATABASE db;'
	@echo "Applying migrations..."
	@PGPASSWORD=postgres psql -h localhost -U postgres -d db -f migrations/001_create_tables.sql

# Запуск тестов
test:
	@echo "Running tests..."
	@go test ./...

# Очистка
clean:
	@echo "Cleaning..."
	@rm -rf bin/

help:
	@echo "Available commands:"
	@echo "  make run          - Run the application"
	@echo "  make build        - Build the binary"
	@echo "  make docker-up    - Start infrastructure services"
	@echo "  make docker-down  - Stop infrastructure services"
	@echo "  make migrate      - Apply database migrations"
	@echo "  make test         - Run tests"
	@echo "  make clean        - Clean build artifacts"
`

	return g.writer.WriteFile("Makefile", content)
}

// generateDockerCompose генерирует docker-compose.yml
func (g *MainGenerator) generateDockerCompose(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `version: '3.8'

services:
  postgres:
    image: postgres:15
    container_name: app-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: app-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nats:
    image: nats:2.10-alpine
    container_name: app-nats
    ports:
      - "4222:4222"
      - "8222:8222"
    command: ["-js", "-m", "8222"]
    networks:
      - app_network
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8222/healthz"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  redis_data:

networks:
  app_network:
    driver: bridge
`

	return g.writer.WriteFile("docker-compose.yml", content)
}

// generateEnvExample генерирует .env.example
func (g *MainGenerator) generateEnvExample(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `# Server Configuration
SERVER_PORT=8080

# Database Configuration
DATABASE_DSN=postgres://postgres:postgres@localhost:5432/db?sslmode=disable

# Redis Configuration
REDIS_ADDR=localhost:6379
REDIS_PASSWORD=
REDIS_DB=0

# NATS Configuration
NATS_URL=nats://localhost:4222

# Metrics Configuration
METRICS_ENABLED=true
METRICS_PORT=2112
`

	return g.writer.WriteFile(".env.example", content)
}

// generateREADME генерирует README.md
func (g *MainGenerator) generateREADME(_ *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString(fmt.Sprintf("# %s\n\n", config.ModulePath))
	content.WriteString("CQRS приложение, сгенерированное с помощью Potter Code Generator.\n\n")
	content.WriteString("## Архитектура\n\n")
	content.WriteString("Приложение использует Clean Architecture с разделением на слои:\n\n")
	content.WriteString("- **Domain** - доменная логика, агрегаты, события\n")
	content.WriteString("- **Application** - команды, запросы, handlers\n")
	content.WriteString("- **Infrastructure** - репозитории, cache, адаптеры\n")
	content.WriteString("- **Presentation** - REST API handlers\n\n")
	content.WriteString("## Установка и запуск\n\n")
	content.WriteString("```bash\n")
	content.WriteString("make docker-up    # Запуск инфраструктуры\n")
	content.WriteString("make migrate      # Применение миграций\n")
	content.WriteString("make run          # Запуск приложения\n")
	content.WriteString("```\n\n")
	content.WriteString("## API Endpoints\n\n")
	content.WriteString("См. `api_examples.md` для примеров использования API.\n\n")

	return g.writer.WriteFile("README.md", content.String())
}

// generateGoMod генерирует go.mod
func (g *MainGenerator) generateGoMod(_ *ParsedSpec, config *GeneratorConfig) error {
	content := fmt.Sprintf(`module %s

go 1.21

require (
	github.com/gin-gonic/gin v1.9.1
	github.com/google/uuid v1.4.0
	github.com/jackc/pgx/v5 v5.5.1
	github.com/nats-io/nats.go v1.31.0
	github.com/redis/go-redis/v9 v9.3.0
	go.opentelemetry.io/otel v1.21.0
	go.opentelemetry.io/otel/exporters/prometheus v0.44.0
	go.opentelemetry.io/otel/metric v1.21.0
	go.opentelemetry.io/otel/sdk/metric v1.21.0
	potter v0.0.0
)

replace potter => ../..
`, config.ModulePath)

	return g.writer.WriteFile("go.mod", content)
}
