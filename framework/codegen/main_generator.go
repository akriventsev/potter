package codegen

import (
	"fmt"
	"strings"
)

// MainGenerator генератор main.go и вспомогательных файлов
type MainGenerator struct {
	*BaseGenerator
}

// NewMainGenerator создает новый генератор main
func NewMainGenerator(outputDir string) *MainGenerator {
	return &MainGenerator{
		BaseGenerator: NewBaseGenerator("main", outputDir),
	}
}

// Generate генерирует main.go и вспомогательные файлы
func (g *MainGenerator) Generate(spec *ParsedSpec, config *GeneratorConfig) error {
	if err := g.generateMain(spec, config); err != nil {
		return fmt.Errorf("failed to generate main: %w", err)
	}

	if err := g.generateMakefile(spec, config); err != nil {
		return fmt.Errorf("failed to generate Makefile: %w", err)
	}

	if err := g.generateDockerCompose(spec, config); err != nil {
		return fmt.Errorf("failed to generate docker-compose: %w", err)
	}

	if err := g.generateEnvExample(spec, config); err != nil {
		return fmt.Errorf("failed to generate .env.example: %w", err)
	}

	if err := g.generateREADME(spec, config); err != nil {
		return fmt.Errorf("failed to generate README: %w", err)
	}

	if err := g.generateGoMod(spec, config); err != nil {
		return fmt.Errorf("failed to generate go.mod: %w", err)
	}

	return nil
}

// generateMain генерирует cmd/server/main.go
func (g *MainGenerator) generateMain(spec *ParsedSpec, config *GeneratorConfig) error {
	// Определение транспортов
	hasREST := false
	hasGraphQL := false
	hasGRPC := false

	for _, transport := range spec.Transports {
		switch transport {
		case "REST":
			hasREST = true
		case "GraphQL":
			hasGraphQL = true
		case "gRPC":
			hasGRPC = true
		}
	}

	// Если транспорты не указаны, по умолчанию используем REST
	if len(spec.Transports) == 0 {
		hasREST = true
	}

	var content strings.Builder

	content.WriteString("// Code generated by potter-gen. DO NOT EDIT.\n\n")
	content.WriteString("package main\n\n")
	content.WriteString("import (\n")
	content.WriteString("\t\"context\"\n")
	content.WriteString("\t\"fmt\"\n")
	content.WriteString("\t\"log\"\n")
	if hasREST || hasGraphQL {
		content.WriteString("\t\"net/http\"\n")
	}
	content.WriteString("\t\"os\"\n")
	content.WriteString("\t\"os/signal\"\n")
	content.WriteString("\t\"syscall\"\n")
	content.WriteString("\t\"time\"\n")
	content.WriteString("\n")

	content.WriteString("\t\"github.com/jackc/pgx/v5/pgxpool\"\n")
	content.WriteString("\t\"github.com/redis/go-redis/v9\"\n")
	content.WriteString("\t\"go.opentelemetry.io/otel/sdk/metric\"\n")
	content.WriteString(fmt.Sprintf("\t\"%s/application/command\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/application/query\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/config\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/cache\"\n", config.ModulePath))
	content.WriteString(fmt.Sprintf("\t\"%s/infrastructure/repository\"\n", config.ModulePath))
	if hasREST {
		content.WriteString("\t\"github.com/gin-gonic/gin\"\n")
		content.WriteString(fmt.Sprintf("\t\"%s/presentation/rest\"\n", config.ModulePath))
	}
	if hasGraphQL {
		content.WriteString("\t\"github.com/99designs/gqlgen/graphql\"\n")
		content.WriteString(fmt.Sprintf("\tgraphqladapter \"%s/presentation/graphql\"\n", config.ModulePath))
	}
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Удаляем @main или другие суффиксы версии для import-путей
	baseImportPath := strings.Split(potterPath, "@")[0]
	content.WriteString(fmt.Sprintf("\tadapterevents \"%s/framework/adapters/events\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/adapters/messagebus\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/metrics\"\n", baseImportPath))
	content.WriteString(fmt.Sprintf("\t\"%s/framework/transport\"\n", baseImportPath))
	content.WriteString(")\n\n")

	content.WriteString("func main() {\n")
	content.WriteString("\t// Загрузка конфигурации\n")
	content.WriteString("\tcfg := config.LoadConfig()\n\n")
	content.WriteString("\tctx, cancel := context.WithCancel(context.Background())\n")
	content.WriteString("\tdefer cancel()\n\n")
	content.WriteString("\t// Инициализация метрик\n")
	content.WriteString("\tvar metricsProvider *metric.MeterProvider\n")
	content.WriteString("\tif cfg.Metrics.Enabled {\n")
	content.WriteString("\t\tmetricsConfig := &metrics.MetricsConfig{\n")
	content.WriteString("\t\t\tExporterType:   \"prometheus\",\n")
	content.WriteString("\t\t\tPrometheusPort: cfg.Metrics.Port,\n")
	content.WriteString("\t\t\tSamplingRate:   1.0,\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tprovider, err := metrics.SetupMetrics(metricsConfig)\n")
	content.WriteString("\t\tif err != nil {\n")
	content.WriteString("\t\t\tlog.Fatalf(\"Failed to setup metrics: %v\", err)\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tmetricsProvider = provider\n")
	content.WriteString("\t\tdefer func() {\n")
	content.WriteString("\t\t\tif err := metrics.ShutdownMetrics(ctx, metricsProvider); err != nil {\n")
	content.WriteString("\t\t\t\tlog.Printf(\"Failed to shutdown metrics: %v\", err)\n")
	content.WriteString("\t\t\t}\n")
	content.WriteString("\t\t}()\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Создание PostgreSQL connection pool\n")
	content.WriteString("\tdb, err := pgxpool.New(ctx, cfg.Database.DSN)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to connect to database: %v\", err)\n")
	content.WriteString("\t}\n")
	content.WriteString("\tdefer db.Close()\n\n")
	content.WriteString("\t// Создание Redis client\n")
	content.WriteString("\tredisClient := redis.NewClient(&redis.Options{\n")
	content.WriteString("\t\tAddr:     cfg.Redis.Addr,\n")
	content.WriteString("\t\tPassword: cfg.Redis.Password,\n")
	content.WriteString("\t\tDB:       cfg.Redis.DB,\n")
	content.WriteString("\t})\n")
	content.WriteString("\tdefer redisClient.Close()\n\n")
	content.WriteString("\t// Проверка подключения к Redis\n")
	content.WriteString("\tif err := redisClient.Ping(ctx).Err(); err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to connect to Redis: %v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\t// Создание NATS client\n")
	content.WriteString("\tnatsAdapter, err := messagebus.NewNATSAdapter(cfg.NATS.URL)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to create NATS adapter: %v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\tif err := natsAdapter.Start(ctx); err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to start NATS adapter: %v\", err)\n")
	content.WriteString("\t}\n")
	content.WriteString("\tdefer natsAdapter.Stop(ctx)\n\n")
	content.WriteString("\t// Создание сервисов\n")
	content.WriteString("\tcacheService := cache.NewRedisCacheService(redisClient)\n\n")

	// Создание репозиториев
	content.WriteString("\t// Создание репозиториев\n")
	for _, agg := range spec.Aggregates {
		repoName := fmt.Sprintf("%sRepo", strings.ToLower(agg.Name))
		content.WriteString(fmt.Sprintf("\t%s := repository.NewPostgres%sRepository(db, cacheService)\n",
			repoName, agg.Name))
	}
	content.WriteString("\n")

	// Создание EventPublisher
	content.WriteString("\t// Создание EventPublisher\n")
	content.WriteString("\teventConfig := adapterevents.NATSEventConfig{\n")
	content.WriteString("\t\tConn:          natsAdapter.Conn(),\n")
	content.WriteString("\t\tSubjectPrefix: \"events\",\n")
	content.WriteString("\t}\n")
	content.WriteString("\teventPublisher, err := adapterevents.NewNATSEventAdapter(eventConfig)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to create event publisher: %v\", err)\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\tif err := eventPublisher.Start(ctx); err != nil {\n")
	content.WriteString("\t\tlog.Fatalf(\"Failed to start event publisher: %v\", err)\n")
	content.WriteString("\t}\n")
	content.WriteString("\tdefer eventPublisher.Stop(ctx)\n\n")

	// Создание CommandBus и QueryBus
	content.WriteString("\t// Создание CommandBus и QueryBus\n")
	content.WriteString("\tcommandBus := transport.NewInMemoryCommandBus()\n")
	content.WriteString("\tqueryBus := transport.NewInMemoryQueryBus()\n\n")

	// Регистрация command handlers
	content.WriteString("\t// Регистрация command handlers\n")
	for _, cmd := range spec.Commands {
		handlerName := fmt.Sprintf("%sHandler", cmd.Name)
		aggName := strings.ToLower(cmd.Aggregate)
		content.WriteString(fmt.Sprintf("\t%s := command.New%sHandler(%sRepo, eventPublisher)\n",
			strings.ToLower(handlerName), cmd.Name, aggName))
		content.WriteString(fmt.Sprintf("\tif err := commandBus.Register(%s); err != nil {\n",
			strings.ToLower(handlerName)))
		content.WriteString(fmt.Sprintf("\t\tlog.Fatalf(\"Failed to register %s handler: %%v\", err)\n", cmd.Name))
		content.WriteString("\t}\n")
	}
	content.WriteString("\n")

	// Регистрация query handlers
	content.WriteString("\t// Регистрация query handlers\n")
	for _, query := range spec.Queries {
		handlerName := fmt.Sprintf("%sHandler", query.Name)

		// Определяем параметры конструктора на основе read_model и имени query
		hasReadModel := query.ReadModel != ""

		if hasReadModel {
			// Query имеет read_model - только cache (если cacheable)
			if query.Cacheable {
				content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(cacheService)\n",
					strings.ToLower(handlerName), query.Name))
			} else {
				content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler()\n",
					strings.ToLower(handlerName), query.Name))
			}
		} else {
			// Query НЕ имеет read_model - определяем агрегат из имени query
			aggregateName := inferAggregateFromQueryName(query.Name)
			foundAggregate := findAggregateByName(spec.Aggregates, aggregateName)

			if foundAggregate != nil {
				// Агрегат найден в спецификации - используем его репозиторий
				repoVarName := strings.ToLower(foundAggregate.Name) + "Repo"
				if query.Cacheable {
					content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(%s, cacheService)\n",
						strings.ToLower(handlerName), query.Name, repoVarName))
				} else {
					content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(%s)\n",
						strings.ToLower(handlerName), query.Name, repoVarName))
				}
			} else {
				// Агрегат не найден в спецификации - вызываем конструктор без репозитория
				// (только cache, если cacheable, или без параметров)
				// Это синхронизировано с логикой ApplicationGenerator.generateQuery()
				if query.Cacheable {
					content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler(cacheService)\n",
						strings.ToLower(handlerName), query.Name))
				} else {
					content.WriteString(fmt.Sprintf("\t%s := query.New%sHandler()\n",
						strings.ToLower(handlerName), query.Name))
				}
			}
		}

		content.WriteString(fmt.Sprintf("\tif err := queryBus.Register(%s); err != nil {\n",
			strings.ToLower(handlerName)))
		content.WriteString(fmt.Sprintf("\t\tlog.Fatalf(\"Failed to register %s handler: %%v\", err)\n", query.Name))
		content.WriteString("\t}\n")
	}
	content.WriteString("\n")

	// Инициализация транспортов
	content.WriteString("\t// Инициализация транспортов\n")
	content.WriteString("\tvar restServer *http.Server\n")
	if hasGraphQL {
		content.WriteString("\tvar graphQLAdapter *transport.GraphQLAdapter\n")
	}
	content.WriteString("\n")

	// Создание REST handler и сервера
	if hasREST {
		content.WriteString("\t// Создание REST handler\n")
		content.WriteString("\trestHandler := rest.NewHandler(commandBus, queryBus)\n\n")
		content.WriteString("\t// Настройка Gin router\n")
		content.WriteString("\trouter := gin.Default()\n")
		content.WriteString("\trestHandler.RegisterRoutes(router)\n\n")
		content.WriteString("\t// Запуск REST HTTP сервера\n")
		content.WriteString("\trestServer = &http.Server{\n")
		content.WriteString("\t\tAddr:    fmt.Sprintf(\":%%d\", cfg.Server.Port),\n")
		content.WriteString("\t\tHandler: router,\n")
		content.WriteString("\t}\n\n")
		content.WriteString("\tgo func() {\n")
		content.WriteString("\t\tlog.Printf(\"REST server starting on port %%d\", cfg.Server.Port)\n")
		content.WriteString("\t\tif err := restServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n")
		content.WriteString("\t\t\tlog.Fatalf(\"Failed to start REST server: %%v\", err)\n")
		content.WriteString("\t\t}\n")
		content.WriteString("\t}()\n\n")
	}

	// Создание GraphQL адаптера и сервера
	if hasGraphQL {
		content.WriteString("\t// Создание GraphQL адаптера\n")
		content.WriteString("\t// Примечание: executableSchema должен быть сгенерирован через gqlgen\n")
		content.WriteString("\t// После генерации кода выполните: cd api/graphql && gqlgen generate\n")
		content.WriteString("\t// Затем загрузите схему из api/graphql/generated.go\n")
		content.WriteString("\t// Пример импорта и инициализации:\n")
		content.WriteString("\t// import graphqlgen \"github.com/your-module/api/graphql\"\n")
		content.WriteString("\t// executableSchema := graphqlgen.NewExecutableSchema(graphqlgen.Config{Resolvers: graphqlgen.NewResolverRoot()})\n")
		content.WriteString("\tvar executableSchema graphql.ExecutableSchema\n")
		content.WriteString("\t// TODO: Инициализируйте executableSchema перед созданием адаптера\n")
		content.WriteString("\t// Раскомментируйте и настройте следующие строки после генерации gqlgen:\n")
		content.WriteString(fmt.Sprintf("\t// import graphqlgen \"%s/api/graphql\"\n", config.ModulePath))
		content.WriteString("\t// executableSchema = graphqlgen.NewExecutableSchema(graphqlgen.Config{Resolvers: graphqlgen.NewResolverRoot()})\n")
		content.WriteString("\tif executableSchema == nil {\n")
		content.WriteString("\t\tlog.Println(\"Warning: executableSchema is not initialized. Skipping GraphQL adapter creation.\")\n")
		content.WriteString("\t\tlog.Println(\"To enable GraphQL, initialize executableSchema using gqlgen-generated code.\")\n")
		content.WriteString("\t} else {\n")
		content.WriteString("\t\tgraphQLAdapter, err = graphqladapter.NewGraphQLAdapter(cfg, commandBus, queryBus, eventPublisher, executableSchema)\n")
		content.WriteString("\t\tif err != nil {\n")
		content.WriteString("\t\t\tlog.Fatalf(\"Failed to create GraphQL adapter: %%v\", err)\n")
		content.WriteString("\t\t}\n\n")
		content.WriteString("\t\t// Запуск GraphQL сервера\n")
		content.WriteString("\t\tif err := graphQLAdapter.Start(ctx); err != nil {\n")
		content.WriteString("\t\t\tlog.Fatalf(\"Failed to start GraphQL adapter: %%v\", err)\n")
		content.WriteString("\t\t}\n")
		content.WriteString("\t\tdefer graphQLAdapter.Stop(ctx)\n\n")
		content.WriteString("\t\tlog.Printf(\"GraphQL server started on port %%d\", cfg.GraphQL.Port)\n")
		content.WriteString("\t\tif cfg.GraphQL.EnablePlayground {\n")
		content.WriteString("\t\t\tlog.Printf(\"GraphQL Playground: http://localhost:%%d/graphql\", cfg.GraphQL.Port)\n")
		content.WriteString("\t\t}\n\n")
		content.WriteString("\t}\n\n")
	}

	// gRPC сервер (в разработке)
	if hasGRPC {
		content.WriteString("\t// TODO: Инициализация gRPC сервера\n")
		content.WriteString("\t// gRPCServer := grpc.NewServer()\n")
		content.WriteString("\t// ... регистрация gRPC handlers ...\n\n")
	}

	content.WriteString("\t// Graceful shutdown\n")
	content.WriteString("\tquit := make(chan os.Signal, 1)\n")
	content.WriteString("\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n")
	content.WriteString("\t<-quit\n\n")
	content.WriteString("\tlog.Println(\"Shutting down application...\")\n\n")
	content.WriteString("\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)\n")
	content.WriteString("\tdefer shutdownCancel()\n\n")

	if hasREST {
		content.WriteString("\t// Остановка REST сервера\n")
		content.WriteString("\tif restServer != nil {\n")
		content.WriteString("\t\tif err := restServer.Shutdown(shutdownCtx); err != nil {\n")
		content.WriteString("\t\t\tlog.Printf(\"Error during REST server shutdown: %%v\", err)\n")
		content.WriteString("\t\t}\n")
		content.WriteString("\t}\n\n")
	}

	if hasGraphQL {
		content.WriteString("\t// Остановка GraphQL сервера\n")
		content.WriteString("\tif graphQLAdapter != nil {\n")
		content.WriteString("\t\tif err := graphQLAdapter.Stop(shutdownCtx); err != nil {\n")
		content.WriteString("\t\t\tlog.Printf(\"Error during GraphQL server shutdown: %%v\", err)\n")
		content.WriteString("\t\t}\n")
		content.WriteString("\t}\n\n")
	}

	content.WriteString("\tlog.Println(\"Application stopped\")\n")
	content.WriteString("}\n")

	path := "cmd/server/main.go"
	return g.writer.WriteFile(path, content.String())
}

// generateMakefile генерирует Makefile
func (g *MainGenerator) generateMakefile(_ *ParsedSpec, config *GeneratorConfig) error {
	// Определяем путь Potter с версией для использования в Makefile
	potterPath := ""
	if config != nil {
		potterPath = config.PotterImportPath
	}
	if potterPath == "" {
		potterPath = "github.com/akriventsev/potter"
	}
	// Если путь не содержит версию, добавляем @main как дефолт
	if !strings.Contains(potterPath, "@") {
		potterPath = potterPath + "@main"
	}

	content := fmt.Sprintf(`.PHONY: run build docker-up docker-down migrate test clean deps help

# Переменные
DATABASE_DSN ?= postgres://postgres:postgres@localhost:5432/db?sslmode=disable
REDIS_ADDR ?= localhost:6379
NATS_URL ?= nats://localhost:4222
POTTER_IMPORT_PATH ?= %s

# Запуск приложения
run:
	@echo "Running application..."
	@go run cmd/server/main.go

# Сборка бинарника
build:
	@echo "Building application..."
	@mkdir -p bin
	@go build -o bin/server cmd/server/main.go

# Запуск docker-compose
docker-up:
	@echo "Starting infrastructure services..."
	@docker-compose up -d

# Остановка docker-compose
docker-down:
	@echo "Stopping infrastructure services..."
	@docker-compose down

# Применение миграций
migrate:
	@echo "Waiting for PostgreSQL to be ready..."
	@until PGPASSWORD=postgres psql -h localhost -U postgres -d postgres -c '\q' 2>/dev/null; do sleep 1; done
	@echo "Creating database if it doesn't exist..."
	@PGPASSWORD=postgres psql -h localhost -U postgres -d postgres -tc "SELECT 1 FROM pg_database WHERE datname = 'db'" | grep -q 1 || PGPASSWORD=postgres psql -h localhost -U postgres -d postgres -c 'CREATE DATABASE db;'
	@echo "Applying migrations..."
	@PGPASSWORD=postgres psql -h localhost -U postgres -d db -f migrations/001_create_tables.sql

# Запуск тестов
test:
	@echo "Running tests..."
	@go test ./...

# Очистка
clean:
	@echo "Cleaning..."
	@rm -rf bin/

# Инициализация зависимостей
deps:
	@echo "Initializing Go modules..."
	@go get $(POTTER_IMPORT_PATH)
	@go mod tidy
	@echo "Dependencies initialized successfully"

help:
	@echo "Available commands:"
	@echo "  make run          - Run the application"
	@echo "  make build        - Build the binary"
	@echo "  make docker-up    - Start infrastructure services"
	@echo "  make docker-down  - Stop infrastructure services"
	@echo "  make migrate      - Apply database migrations"
	@echo "  make test         - Run tests"
	@echo "  make clean        - Clean build artifacts"
	@echo "  make deps         - Initialize Go module dependencies"
`, potterPath)

	return g.writer.WriteFile("Makefile", content)
}

// generateDockerCompose генерирует docker-compose.yml
func (g *MainGenerator) generateDockerCompose(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `version: '3.8'

services:
  postgres:
    image: postgres:15
    container_name: app-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: app-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nats:
    image: nats:2.10-alpine
    container_name: app-nats
    ports:
      - "4222:4222"
      - "8222:8222"
    command: ["-js", "-m", "8222"]
    networks:
      - app_network
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8222/healthz"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  redis_data:

networks:
  app_network:
    driver: bridge
`

	return g.writer.WriteFile("docker-compose.yml", content)
}

// generateEnvExample генерирует .env.example
func (g *MainGenerator) generateEnvExample(_ *ParsedSpec, _ *GeneratorConfig) error {
	content := `# Server Configuration
SERVER_PORT=8080

# Database Configuration
DATABASE_DSN=postgres://postgres:postgres@localhost:5432/db?sslmode=disable

# Redis Configuration
REDIS_ADDR=localhost:6379
REDIS_PASSWORD=
REDIS_DB=0

# NATS Configuration
NATS_URL=nats://localhost:4222

# Metrics Configuration
METRICS_ENABLED=true
METRICS_PORT=2112

# GraphQL Configuration
GRAPHQL_PORT=8082
GRAPHQL_PLAYGROUND_ENABLED=true
GRAPHQL_INTROSPECTION_ENABLED=true
GRAPHQL_COMPLEXITY_LIMIT=1000
GRAPHQL_MAX_DEPTH=15
`

	return g.writer.WriteFile(".env.example", content)
}

// generateREADME генерирует README.md
func (g *MainGenerator) generateREADME(_ *ParsedSpec, config *GeneratorConfig) error {
	var content strings.Builder

	content.WriteString(fmt.Sprintf("# %s\n\n", config.ModulePath))
	content.WriteString("CQRS приложение, сгенерированное с помощью Potter Code Generator.\n\n")
	content.WriteString("## Архитектура\n\n")
	content.WriteString("Приложение использует Clean Architecture с разделением на слои:\n\n")
	content.WriteString("- **Domain** - доменная логика, агрегаты, события\n")
	content.WriteString("- **Application** - команды, запросы, handlers\n")
	content.WriteString("- **Infrastructure** - репозитории, cache, адаптеры\n")
	content.WriteString("- **Presentation** - REST API handlers\n\n")
	content.WriteString("## Установка и запуск\n\n")
	content.WriteString("Potter framework добавляется автоматически при генерации кода через `go get @main`.\n")
	content.WriteString("Если автоматическая инициализация не удалась или необходимо переинициализировать зависимости:\n\n")
	content.WriteString("```bash\n")
	content.WriteString("make deps         # Инициализация/переинициализация зависимостей\n")
	content.WriteString("make docker-up    # Запуск инфраструктуры\n")
	content.WriteString("make migrate      # Применение миграций\n")
	content.WriteString("make run          # Запуск приложения\n")
	content.WriteString("```\n\n")
	content.WriteString("## API Endpoints\n\n")
	content.WriteString("См. `api_examples.md` для примеров использования API.\n\n")
	content.WriteString("## Troubleshooting\n\n")
	content.WriteString("### Ошибки \"missing go.sum entry\" или \"unknown revision\"\n\n")
	content.WriteString("Если вы видите ошибки о недостающих записях в go.sum или неизвестных версиях, выполните:\n\n")
	content.WriteString("```bash\n")
	content.WriteString("make deps\n")
	content.WriteString("```\n\n")
	content.WriteString("Эта команда переинициализирует все зависимости Go модулей, включая Potter framework.\n\n")

	return g.writer.WriteFile("README.md", content.String())
}

// generateGoMod генерирует go.mod
func (g *MainGenerator) generateGoMod(_ *ParsedSpec, config *GeneratorConfig) error {
	content := fmt.Sprintf(`module %s

go 1.21

require (
	github.com/gin-gonic/gin v1.9.1
	github.com/google/uuid v1.4.0
	github.com/jackc/pgx/v5 v5.5.1
	github.com/nats-io/nats.go v1.31.0
	github.com/redis/go-redis/v9 v9.3.0
	go.opentelemetry.io/otel v1.21.0
	go.opentelemetry.io/otel/exporters/prometheus v0.44.0
	go.opentelemetry.io/otel/metric v1.21.0
	go.opentelemetry.io/otel/sdk/metric v1.21.0
)

// Potter framework будет добавлен автоматически при инициализации модулей через 'go get @main'.
// Если автоматическая инициализация не удалась, выполните: make deps
`, config.ModulePath)

	return g.writer.WriteFile("go.mod", content)
}
